{
  "version": 3,
  "sources": ["../src/BitStream.ts", "../src/SuperChatCodec.ts", "../src/main.ts"],
  "sourcesContent": ["/**\n * BitStream - Low-level bit-level reading/writing\n *\n * Handles bit-level precision for encoding/decoding.\n * Maintains a buffer and bit offset for streaming operations.\n */\n\nexport type Endianness = \"big_endian\" | \"little_endian\";\nexport type BitOrder = \"msb_first\" | \"lsb_first\";\n\n/**\n * BitStreamEncoder - Write bits to a byte stream\n */\nexport class BitStreamEncoder {\n  private bytes: number[] = [];\n  private currentByte: number = 0;\n  private bitOffset: number = 0; // Bits used in currentByte (0-7)\n  private totalBitsWritten: number = 0; // Track total bits for finishBits()\n  private bitOrder: BitOrder;\n\n  constructor(bitOrder: BitOrder = \"msb_first\") {\n    this.bitOrder = bitOrder;\n  }\n\n  /**\n   * Write bits to stream\n   * @param value - Value to write (will be masked to size)\n   * @param size - Number of bits to write (1-64)\n   *\n   * Note: bitOrder controls byte-level bit packing (via writeBit),\n   * but multi-bit values are always written LSB-first (standard for bitfields)\n   */\n  writeBits(value: number | bigint, size: number): void {\n    if (size < 1 || size > 64) {\n      throw new Error(`Invalid bit size: ${size} (must be 1-64)`);\n    }\n\n    // Convert to bigint for consistent handling\n    let val = typeof value === 'bigint' ? value : BigInt(value);\n\n    // Mask to size\n    const mask = (1n << BigInt(size)) - 1n;\n    val = val & mask;\n\n    // Write bits according to bit order configuration\n    // msb_first: Write MSB of value first (video codecs, network protocols)\n    // lsb_first: Write LSB of value first (hardware bitfields)\n    if (this.bitOrder === \"lsb_first\") {\n      // LSB first: bit 0 of value goes to first bit position\n      for (let i = 0; i < size; i++) {\n        const bit = Number((val >> BigInt(i)) & 1n);\n        this.writeBit(bit);\n      }\n    } else {\n      // MSB first: bit (size-1) of value goes to first bit position\n      for (let i = size - 1; i >= 0; i--) {\n        const bit = Number((val >> BigInt(i)) & 1n);\n        this.writeBit(bit);\n      }\n    }\n  }\n\n  /**\n   * Write a single bit\n   */\n  private writeBit(bit: number): void {\n    if (this.bitOrder === \"msb_first\") {\n      // MSB first: fill from left to right\n      // Bit 0 is leftmost (MSB), bit 7 is rightmost (LSB)\n      this.currentByte |= (bit << (7 - this.bitOffset));\n    } else {\n      // LSB first: fill from right to left\n      // Bit 0 is rightmost (LSB), bit 7 is leftmost (MSB)\n      this.currentByte |= (bit << this.bitOffset);\n    }\n\n    this.bitOffset++;\n    this.totalBitsWritten++;\n\n    // Byte is full, flush it\n    if (this.bitOffset === 8) {\n      this.bytes.push(this.currentByte);\n      this.currentByte = 0;\n      this.bitOffset = 0;\n    }\n  }\n\n  /**\n   * Write uint8 (8 bits)\n   * Optimized to write directly when byte-aligned\n   */\n  writeUint8(value: number): void {\n    if (this.bitOffset === 0) {\n      // Byte-aligned: write directly\n      this.bytes.push(value & 0xFF);\n    } else {\n      // Not byte-aligned: write LSB-first (standard for byte values)\n      for (let i = 0; i < 8; i++) {\n        const bit = (value >> i) & 1;\n        this.writeBit(bit);\n      }\n    }\n  }\n\n  /**\n   * Write uint16\n   */\n  writeUint16(value: number, endianness: Endianness): void {\n    if (endianness === \"big_endian\") {\n      this.writeUint8((value >> 8) & 0xFF);\n      this.writeUint8(value & 0xFF);\n    } else {\n      this.writeUint8(value & 0xFF);\n      this.writeUint8((value >> 8) & 0xFF);\n    }\n  }\n\n  /**\n   * Write uint32\n   */\n  writeUint32(value: number, endianness: Endianness): void {\n    if (endianness === \"big_endian\") {\n      this.writeUint8((value >>> 24) & 0xFF);\n      this.writeUint8((value >>> 16) & 0xFF);\n      this.writeUint8((value >>> 8) & 0xFF);\n      this.writeUint8(value & 0xFF);\n    } else {\n      this.writeUint8(value & 0xFF);\n      this.writeUint8((value >>> 8) & 0xFF);\n      this.writeUint8((value >>> 16) & 0xFF);\n      this.writeUint8((value >>> 24) & 0xFF);\n    }\n  }\n\n  /**\n   * Write uint64 (as bigint)\n   */\n  writeUint64(value: bigint, endianness: Endianness): void {\n    if (endianness === \"big_endian\") {\n      this.writeUint8(Number((value >> 56n) & 0xFFn));\n      this.writeUint8(Number((value >> 48n) & 0xFFn));\n      this.writeUint8(Number((value >> 40n) & 0xFFn));\n      this.writeUint8(Number((value >> 32n) & 0xFFn));\n      this.writeUint8(Number((value >> 24n) & 0xFFn));\n      this.writeUint8(Number((value >> 16n) & 0xFFn));\n      this.writeUint8(Number((value >> 8n) & 0xFFn));\n      this.writeUint8(Number(value & 0xFFn));\n    } else {\n      this.writeUint8(Number(value & 0xFFn));\n      this.writeUint8(Number((value >> 8n) & 0xFFn));\n      this.writeUint8(Number((value >> 16n) & 0xFFn));\n      this.writeUint8(Number((value >> 24n) & 0xFFn));\n      this.writeUint8(Number((value >> 32n) & 0xFFn));\n      this.writeUint8(Number((value >> 40n) & 0xFFn));\n      this.writeUint8(Number((value >> 48n) & 0xFFn));\n      this.writeUint8(Number((value >> 56n) & 0xFFn));\n    }\n  }\n\n  /**\n   * Write int8 (two's complement)\n   */\n  writeInt8(value: number): void {\n    const unsigned = value < 0 ? 256 + value : value;\n    this.writeUint8(unsigned);\n  }\n\n  /**\n   * Write int16 (two's complement)\n   */\n  writeInt16(value: number, endianness: Endianness): void {\n    const unsigned = value < 0 ? 65536 + value : value;\n    this.writeUint16(unsigned, endianness);\n  }\n\n  /**\n   * Write int32 (two's complement)\n   */\n  writeInt32(value: number, endianness: Endianness): void {\n    const unsigned = value < 0 ? 4294967296 + value : value;\n    this.writeUint32(unsigned >>> 0, endianness);\n  }\n\n  /**\n   * Write int64 (two's complement)\n   */\n  writeInt64(value: bigint, endianness: Endianness): void {\n    const unsigned = value < 0n ? (1n << 64n) + value : value;\n    this.writeUint64(unsigned, endianness);\n  }\n\n  /**\n   * Write float32 (IEEE 754)\n   */\n  writeFloat32(value: number, endianness: Endianness): void {\n    const buffer = new ArrayBuffer(4);\n    const view = new DataView(buffer);\n    view.setFloat32(0, value, endianness === \"little_endian\");\n\n    for (let i = 0; i < 4; i++) {\n      this.writeUint8(view.getUint8(i));\n    }\n  }\n\n  /**\n   * Write float64 (IEEE 754)\n   */\n  writeFloat64(value: number, endianness: Endianness): void {\n    const buffer = new ArrayBuffer(8);\n    const view = new DataView(buffer);\n    view.setFloat64(0, value, endianness === \"little_endian\");\n\n    for (let i = 0; i < 8; i++) {\n      this.writeUint8(view.getUint8(i));\n    }\n  }\n\n  /**\n   * Get current byte offset (position in buffer)\n   * Returns the number of complete bytes written (for compression dictionary tracking)\n   */\n  get byteOffset(): number {\n    return this.bytes.length;\n  }\n\n  /**\n   * Get encoded bytes\n   * Flushes any partial byte (pads with zeros)\n   */\n  finish(): Uint8Array {\n    // Flush partial byte if any\n    if (this.bitOffset > 0) {\n      this.bytes.push(this.currentByte);\n      this.currentByte = 0;\n      this.bitOffset = 0;\n    }\n\n    return new Uint8Array(this.bytes);\n  }\n\n  /**\n   * Get bits as array (for testing)\n   * Returns only the exact bits that were written, not padded to byte boundary\n   */\n  finishBits(): number[] {\n    const bytes = this.finish();\n    const bits: number[] = [];\n\n    // Extract only the bits that were actually written\n    const bitOrder = this.bitOrder;\n    for (let byteIndex = 0; byteIndex < bytes.length; byteIndex++) {\n      const byte = bytes[byteIndex];\n      const bitsInThisByte = Math.min(8, this.totalBitsWritten - byteIndex * 8);\n\n      if (bitOrder === \"msb_first\") {\n        // MSB first: bits are filled left to right\n        for (let i = 7; i >= 8 - bitsInThisByte; i--) {\n          bits.push((byte >> i) & 1);\n        }\n      } else {\n        // LSB first: bits are filled right to left\n        for (let i = 0; i < bitsInThisByte; i++) {\n          bits.push((byte >> i) & 1);\n        }\n      }\n    }\n\n    return bits;\n  }\n}\n\n/**\n * BitStreamDecoder - Read bits from a byte stream\n */\nexport class BitStreamDecoder {\n  private bytes: Uint8Array;\n  private byteOffset: number = 0;\n  private bitOffset: number = 0; // Bits read from current byte (0-7)\n  private bitOrder: BitOrder;\n  private savedPositions: number[] = []; // Stack for push/popPosition\n\n  // Position stack depth limit (prevents DoS via deeply nested pointers)\n  private static readonly MAX_POSITION_STACK_DEPTH = 128;\n\n  constructor(bytes: Uint8Array | number[], bitOrder: BitOrder = \"msb_first\") {\n    this.bytes = bytes instanceof Uint8Array ? bytes : new Uint8Array(bytes);\n    this.bitOrder = bitOrder;\n  }\n\n  /**\n   * Read bits from stream\n   */\n  readBits(size: number): bigint {\n    if (size < 1 || size > 64) {\n      throw new Error(`Invalid bit size: ${size} (must be 1-64)`);\n    }\n\n    let result = 0n;\n\n    // Read bits according to bit order configuration\n    if (this.bitOrder === \"lsb_first\") {\n      // LSB first: bit 0 comes from first bit position\n      for (let i = 0; i < size; i++) {\n        const bit = this.readBit();\n        result = result | (BigInt(bit) << BigInt(i));\n      }\n    } else {\n      // MSB first: bit (size-1) comes from first bit position\n      for (let i = size - 1; i >= 0; i--) {\n        const bit = this.readBit();\n        result = result | (BigInt(bit) << BigInt(i));\n      }\n    }\n\n    return result;\n  }\n\n  /**\n   * Read a single bit\n   * Public for testing bit-alignment behavior\n   */\n  readBit(): number {\n    if (this.byteOffset >= this.bytes.length) {\n      throw new Error(\"Unexpected end of stream\");\n    }\n\n    const currentByte = this.bytes[this.byteOffset];\n    let bit: number;\n\n    if (this.bitOrder === \"msb_first\") {\n      // MSB first: read from left to right\n      bit = (currentByte >> (7 - this.bitOffset)) & 1;\n    } else {\n      // LSB first: read from right to left\n      bit = (currentByte >> this.bitOffset) & 1;\n    }\n\n    this.bitOffset++;\n\n    if (this.bitOffset === 8) {\n      this.byteOffset++;\n      this.bitOffset = 0;\n    }\n\n    return bit;\n  }\n\n  /**\n   * Read uint8\n   */\n  readUint8(): number {\n    if (this.bitOffset === 0) {\n      // Byte-aligned: read directly\n      if (this.byteOffset >= this.bytes.length) {\n        throw new Error(\"Unexpected end of stream\");\n      }\n      return this.bytes[this.byteOffset++];\n    } else {\n      // Not byte-aligned: read LSB-first (standard for byte values)\n      let result = 0;\n      for (let i = 0; i < 8; i++) {\n        const bit = this.readBit();\n        result = result | (bit << i);\n      }\n      return result;\n    }\n  }\n\n  /**\n   * Read uint16\n   */\n  readUint16(endianness: Endianness): number {\n    if (endianness === \"big_endian\") {\n      const high = this.readUint8();\n      const low = this.readUint8();\n      return (high << 8) | low;\n    } else {\n      const low = this.readUint8();\n      const high = this.readUint8();\n      return (high << 8) | low;\n    }\n  }\n\n  /**\n   * Read uint32\n   */\n  readUint32(endianness: Endianness): number {\n    if (endianness === \"big_endian\") {\n      const b0 = this.readUint8();\n      const b1 = this.readUint8();\n      const b2 = this.readUint8();\n      const b3 = this.readUint8();\n      return ((b0 << 24) | (b1 << 16) | (b2 << 8) | b3) >>> 0;\n    } else {\n      const b0 = this.readUint8();\n      const b1 = this.readUint8();\n      const b2 = this.readUint8();\n      const b3 = this.readUint8();\n      return ((b3 << 24) | (b2 << 16) | (b1 << 8) | b0) >>> 0;\n    }\n  }\n\n  /**\n   * Read uint64\n   */\n  readUint64(endianness: Endianness): bigint {\n    if (endianness === \"big_endian\") {\n      let result = 0n;\n      for (let i = 0; i < 8; i++) {\n        result = (result << 8n) | BigInt(this.readUint8());\n      }\n      return result;\n    } else {\n      let result = 0n;\n      for (let i = 0; i < 8; i++) {\n        result = result | (BigInt(this.readUint8()) << BigInt(i * 8));\n      }\n      return result;\n    }\n  }\n\n  /**\n   * Read int8 (two's complement)\n   */\n  readInt8(): number {\n    const unsigned = this.readUint8();\n    return unsigned > 127 ? unsigned - 256 : unsigned;\n  }\n\n  /**\n   * Read int16 (two's complement)\n   */\n  readInt16(endianness: Endianness): number {\n    const unsigned = this.readUint16(endianness);\n    return unsigned > 32767 ? unsigned - 65536 : unsigned;\n  }\n\n  /**\n   * Read int32 (two's complement)\n   */\n  readInt32(endianness: Endianness): number {\n    const unsigned = this.readUint32(endianness);\n    return unsigned > 2147483647 ? unsigned - 4294967296 : unsigned;\n  }\n\n  /**\n   * Read int64 (two's complement)\n   */\n  readInt64(endianness: Endianness): bigint {\n    const unsigned = this.readUint64(endianness);\n    const max = 1n << 63n;\n    return unsigned >= max ? unsigned - (1n << 64n) : unsigned;\n  }\n\n  /**\n   * Read float32 (IEEE 754)\n   */\n  readFloat32(endianness: Endianness): number {\n    const buffer = new ArrayBuffer(4);\n    const view = new DataView(buffer);\n\n    for (let i = 0; i < 4; i++) {\n      view.setUint8(i, this.readUint8());\n    }\n\n    return view.getFloat32(0, endianness === \"little_endian\");\n  }\n\n  /**\n   * Read float64 (IEEE 754)\n   */\n  readFloat64(endianness: Endianness): number {\n    const buffer = new ArrayBuffer(8);\n    const view = new DataView(buffer);\n\n    for (let i = 0; i < 8; i++) {\n      view.setUint8(i, this.readUint8());\n    }\n\n    return view.getFloat64(0, endianness === \"little_endian\");\n  }\n\n  /**\n   * Get current byte offset (position in buffer)\n   * Returns byte offset regardless of bit offset (DNS pointers are byte-aligned)\n   */\n  get position(): number {\n    return this.byteOffset;\n  }\n\n  /**\n   * Seek to absolute byte offset\n   * Resets bit offset to 0 (byte-aligned)\n   */\n  seek(offset: number): void {\n    if (offset < 0 || offset > this.bytes.length) {\n      throw new Error(\n        `Seek offset ${offset} out of bounds (valid range: 0-${this.bytes.length})`\n      );\n    }\n    this.byteOffset = offset;\n    this.bitOffset = 0;\n  }\n\n  /**\n   * Save current position to stack (for pointer following)\n   */\n  pushPosition(): void {\n    if (this.savedPositions.length >= BitStreamDecoder.MAX_POSITION_STACK_DEPTH) {\n      throw new Error(\n        `Position stack overflow: maximum depth of ${BitStreamDecoder.MAX_POSITION_STACK_DEPTH} exceeded`\n      );\n    }\n    this.savedPositions.push(this.byteOffset);\n  }\n\n  /**\n   * Restore position from stack\n   * Resets bit offset to 0 (byte-aligned)\n   */\n  popPosition(): void {\n    if (this.savedPositions.length === 0) {\n      throw new Error(\"Position stack underflow: attempted to pop from empty stack\");\n    }\n    const saved = this.savedPositions.pop()!;\n    this.byteOffset = saved;\n    this.bitOffset = 0;\n  }\n\n  /**\n   * Peek uint8 without advancing position\n   * Throws error if not byte-aligned\n   */\n  peekUint8(): number {\n    if (this.bitOffset !== 0) {\n      throw new Error(\n        `Peek not byte-aligned: bit offset is ${this.bitOffset} (must be 0)`\n      );\n    }\n\n    if (this.byteOffset >= this.bytes.length) {\n      throw new Error(\n        `Peek out of bounds: attempted to peek 1 byte at offset ${this.byteOffset} (buffer size: ${this.bytes.length})`\n      );\n    }\n\n    return this.bytes[this.byteOffset];\n  }\n\n  /**\n   * Peek uint16 without advancing position\n   * Throws error if not byte-aligned or insufficient bytes\n   */\n  peekUint16(endianness: Endianness): number {\n    if (this.bitOffset !== 0) {\n      throw new Error(\n        `Peek not byte-aligned: bit offset is ${this.bitOffset} (must be 0)`\n      );\n    }\n\n    if (this.byteOffset + 2 > this.bytes.length) {\n      throw new Error(\n        `Peek out of bounds: attempted to peek 2 bytes at offset ${this.byteOffset} (buffer size: ${this.bytes.length})`\n      );\n    }\n\n    if (endianness === \"big_endian\") {\n      return (this.bytes[this.byteOffset] << 8) | this.bytes[this.byteOffset + 1];\n    } else {\n      return this.bytes[this.byteOffset] | (this.bytes[this.byteOffset + 1] << 8);\n    }\n  }\n\n  /**\n   * Peek uint32 without advancing position\n   * Throws error if not byte-aligned or insufficient bytes\n   */\n  peekUint32(endianness: Endianness): number {\n    if (this.bitOffset !== 0) {\n      throw new Error(\n        `Peek not byte-aligned: bit offset is ${this.bitOffset} (must be 0)`\n      );\n    }\n\n    if (this.byteOffset + 4 > this.bytes.length) {\n      throw new Error(\n        `Peek out of bounds: attempted to peek 4 bytes at offset ${this.byteOffset} (buffer size: ${this.bytes.length})`\n      );\n    }\n\n    if (endianness === \"big_endian\") {\n      return (\n        ((this.bytes[this.byteOffset] << 24) |\n          (this.bytes[this.byteOffset + 1] << 16) |\n          (this.bytes[this.byteOffset + 2] << 8) |\n          this.bytes[this.byteOffset + 3]) >>>\n        0\n      );\n    } else {\n      return (\n        ((this.bytes[this.byteOffset + 3] << 24) |\n          (this.bytes[this.byteOffset + 2] << 16) |\n          (this.bytes[this.byteOffset + 1] << 8) |\n          this.bytes[this.byteOffset]) >>>\n        0\n      );\n    }\n  }\n\n  /**\n   * Check if there are more bytes to read\n   */\n  hasMore(): boolean {\n    return this.byteOffset < this.bytes.length || this.bitOffset > 0;\n  }\n}\n", "import { BitStreamEncoder, BitStreamDecoder, Endianness } from \"./BitStream.js\";\n\n/**\n * Length-prefixed UTF-8 string\n */\nexport type String = string;\n\nexport class StringEncoder extends BitStreamEncoder {\n  private compressionDict: Map<string, number> = new Map();\n\n  constructor() {\n    super(\"msb_first\");\n  }\n\n  encode(value: String): Uint8Array {\n    // Reset compression dictionary for each encode\n    this.compressionDict.clear();\n\n    const value_bytes = new TextEncoder().encode(value);\n    this.writeUint16(value_bytes.length, \"big_endian\");\n    for (const byte of value_bytes) {\n      this.writeUint8(byte);\n    }\n    return this.finish();\n  }\n}\n\nexport class StringDecoder extends BitStreamDecoder {\n  constructor(bytes: Uint8Array | number[]) {\n    super(bytes, \"msb_first\");\n  }\n\n  decode(): String {\n    let value: any = {};\n    const result_length = this.readUint16(\"big_endian\");\n    const result_bytes: number[] = [];\n    for (let i = 0; i < result_length; i++) {\n      result_bytes.push(this.readUint8());\n    }\n    value.result = new TextDecoder().decode(new Uint8Array(result_bytes));\n    return value.result;\n  }\n}\n\n/**\n * All messages use this frame format\n */\nexport interface FrameHeader {\n  length: number;\n  version: number;\n  type: number;\n  flags: number;\n}\n\nexport class FrameHeaderEncoder extends BitStreamEncoder {\n  private compressionDict: Map<string, number> = new Map();\n\n  constructor() {\n    super(\"msb_first\");\n  }\n\n  encode(value: FrameHeader): Uint8Array {\n    // Reset compression dictionary for each encode\n    this.compressionDict.clear();\n\n    this.writeUint32(value.length, \"big_endian\");\n    this.writeUint8(value.version);\n    this.writeUint8(value.type);\n    this.writeUint8(value.flags);\n    return this.finish();\n  }\n}\n\nexport class FrameHeaderDecoder extends BitStreamDecoder {\n  constructor(bytes: Uint8Array | number[], private context?: any) {\n    super(bytes, \"msb_first\");\n  }\n\n  decode(): FrameHeader {\n    const value: any = {};\n\n    value.length = this.readUint32(\"big_endian\");\n    value.version = this.readUint8();\n    value.type = this.readUint8();\n    value.flags = this.readUint8();\n    return value;\n  }\n}\n\n/**\n * Authentication request with password\n */\nexport interface AuthRequest {\n  nickname: String;\n  password: String;\n}\n\nexport class AuthRequestEncoder extends BitStreamEncoder {\n  private compressionDict: Map<string, number> = new Map();\n\n  constructor() {\n    super(\"msb_first\");\n  }\n\n  encode(value: AuthRequest): Uint8Array {\n    // Reset compression dictionary for each encode\n    this.compressionDict.clear();\n\n    const value_nickname_bytes = new TextEncoder().encode(value.nickname);\n    this.writeUint16(value_nickname_bytes.length, \"big_endian\");\n    for (const byte of value_nickname_bytes) {\n      this.writeUint8(byte);\n    }\n    const value_password_bytes = new TextEncoder().encode(value.password);\n    this.writeUint16(value_password_bytes.length, \"big_endian\");\n    for (const byte of value_password_bytes) {\n      this.writeUint8(byte);\n    }\n    return this.finish();\n  }\n}\n\nexport class AuthRequestDecoder extends BitStreamDecoder {\n  constructor(bytes: Uint8Array | number[], private context?: any) {\n    super(bytes, \"msb_first\");\n  }\n\n  decode(): AuthRequest {\n    const value: any = {};\n\n    const nickname_length = this.readUint16(\"big_endian\");\n    const nickname_bytes: number[] = [];\n    for (let i = 0; i < nickname_length; i++) {\n      nickname_bytes.push(this.readUint8());\n    }\n    value.nickname = new TextDecoder().decode(new Uint8Array(nickname_bytes));\n    const password_length = this.readUint16(\"big_endian\");\n    const password_bytes: number[] = [];\n    for (let i = 0; i < password_length; i++) {\n      password_bytes.push(this.readUint8());\n    }\n    value.password = new TextDecoder().decode(new Uint8Array(password_bytes));\n    return value;\n  }\n}\n\n/**\n * Authentication response\n */\nexport interface AuthResponse {\n  success: number;\n  user_id: { present: number, value?: bigint };\n  nickname: { present: number, value?: String };\n  message: String;\n}\n\nexport class AuthResponseEncoder extends BitStreamEncoder {\n  private compressionDict: Map<string, number> = new Map();\n\n  constructor() {\n    super(\"msb_first\");\n  }\n\n  encode(value: AuthResponse): Uint8Array {\n    // Reset compression dictionary for each encode\n    this.compressionDict.clear();\n\n    this.writeUint8(value.success);\n    this.writeUint8(value.user_id.present);\n    if (value.user_id.present == 1 && value.user_id.value !== undefined) {\n      this.writeUint64(value.user_id.value, \"big_endian\");\n    }\n    this.writeUint8(value.nickname.present);\n    if (value.nickname.present == 1 && value.nickname.value !== undefined) {\n      const value_nickname_value_bytes = new TextEncoder().encode(value.nickname.value);\n      this.writeUint16(value_nickname_value_bytes.length, \"big_endian\");\n      for (const byte of value_nickname_value_bytes) {\n        this.writeUint8(byte);\n      }\n    }\n    const value_message_bytes = new TextEncoder().encode(value.message);\n    this.writeUint16(value_message_bytes.length, \"big_endian\");\n    for (const byte of value_message_bytes) {\n      this.writeUint8(byte);\n    }\n    return this.finish();\n  }\n}\n\nexport class AuthResponseDecoder extends BitStreamDecoder {\n  constructor(bytes: Uint8Array | number[], private context?: any) {\n    super(bytes, \"msb_first\");\n  }\n\n  decode(): AuthResponse {\n    const value: any = {};\n\n    value.success = this.readUint8();\n    value.user_id = {};\n    value.user_id.present = this.readUint8();\n    if (value.user_id.present == 1) {\n      value.user_id.value = this.readUint64(\"big_endian\");\n    }\n    value.nickname = {};\n    value.nickname.present = this.readUint8();\n    if (value.nickname.present == 1) {\n      const nickname_value_length = this.readUint16(\"big_endian\");\n      const nickname_value_bytes: number[] = [];\n      for (let i = 0; i < nickname_value_length; i++) {\n        nickname_value_bytes.push(this.readUint8());\n      }\n      value.nickname.value = new TextDecoder().decode(new Uint8Array(nickname_value_bytes));\n    }\n    const message_length = this.readUint16(\"big_endian\");\n    const message_bytes: number[] = [];\n    for (let i = 0; i < message_length; i++) {\n      message_bytes.push(this.readUint8());\n    }\n    value.message = new TextDecoder().decode(new Uint8Array(message_bytes));\n    return value;\n  }\n}\n\n/**\n * Set or change nickname\n */\nexport interface SetNickname {\n  nickname: String;\n}\n\nexport class SetNicknameEncoder extends BitStreamEncoder {\n  private compressionDict: Map<string, number> = new Map();\n\n  constructor() {\n    super(\"msb_first\");\n  }\n\n  encode(value: SetNickname): Uint8Array {\n    // Reset compression dictionary for each encode\n    this.compressionDict.clear();\n\n    const value_nickname_bytes = new TextEncoder().encode(value.nickname);\n    this.writeUint16(value_nickname_bytes.length, \"big_endian\");\n    for (const byte of value_nickname_bytes) {\n      this.writeUint8(byte);\n    }\n    return this.finish();\n  }\n}\n\nexport class SetNicknameDecoder extends BitStreamDecoder {\n  constructor(bytes: Uint8Array | number[], private context?: any) {\n    super(bytes, \"msb_first\");\n  }\n\n  decode(): SetNickname {\n    const value: any = {};\n\n    const nickname_length = this.readUint16(\"big_endian\");\n    const nickname_bytes: number[] = [];\n    for (let i = 0; i < nickname_length; i++) {\n      nickname_bytes.push(this.readUint8());\n    }\n    value.nickname = new TextDecoder().decode(new Uint8Array(nickname_bytes));\n    return value;\n  }\n}\n\n/**\n * Nickname change result\n */\nexport interface NicknameResponse {\n  success: number;\n  message: String;\n}\n\nexport class NicknameResponseEncoder extends BitStreamEncoder {\n  private compressionDict: Map<string, number> = new Map();\n\n  constructor() {\n    super(\"msb_first\");\n  }\n\n  encode(value: NicknameResponse): Uint8Array {\n    // Reset compression dictionary for each encode\n    this.compressionDict.clear();\n\n    this.writeUint8(value.success);\n    const value_message_bytes = new TextEncoder().encode(value.message);\n    this.writeUint16(value_message_bytes.length, \"big_endian\");\n    for (const byte of value_message_bytes) {\n      this.writeUint8(byte);\n    }\n    return this.finish();\n  }\n}\n\nexport class NicknameResponseDecoder extends BitStreamDecoder {\n  constructor(bytes: Uint8Array | number[], private context?: any) {\n    super(bytes, \"msb_first\");\n  }\n\n  decode(): NicknameResponse {\n    const value: any = {};\n\n    value.success = this.readUint8();\n    const message_length = this.readUint16(\"big_endian\");\n    const message_bytes: number[] = [];\n    for (let i = 0; i < message_length; i++) {\n      message_bytes.push(this.readUint8());\n    }\n    value.message = new TextDecoder().decode(new Uint8Array(message_bytes));\n    return value;\n  }\n}\n\n/**\n * Post a new message\n */\nexport interface PostMessage {\n  channel_id: bigint;\n  subchannel_id: { present: number, value?: bigint };\n  parent_id: { present: number, value?: bigint };\n  content: String;\n}\n\nexport class PostMessageEncoder extends BitStreamEncoder {\n  private compressionDict: Map<string, number> = new Map();\n\n  constructor() {\n    super(\"msb_first\");\n  }\n\n  encode(value: PostMessage): Uint8Array {\n    // Reset compression dictionary for each encode\n    this.compressionDict.clear();\n\n    this.writeUint64(value.channel_id, \"big_endian\");\n    this.writeUint8(value.subchannel_id.present);\n    if (value.subchannel_id.present == 1 && value.subchannel_id.value !== undefined) {\n      this.writeUint64(value.subchannel_id.value, \"big_endian\");\n    }\n    this.writeUint8(value.parent_id.present);\n    if (value.parent_id.present == 1 && value.parent_id.value !== undefined) {\n      this.writeUint64(value.parent_id.value, \"big_endian\");\n    }\n    const value_content_bytes = new TextEncoder().encode(value.content);\n    this.writeUint16(value_content_bytes.length, \"big_endian\");\n    for (const byte of value_content_bytes) {\n      this.writeUint8(byte);\n    }\n    return this.finish();\n  }\n}\n\nexport class PostMessageDecoder extends BitStreamDecoder {\n  constructor(bytes: Uint8Array | number[], private context?: any) {\n    super(bytes, \"msb_first\");\n  }\n\n  decode(): PostMessage {\n    const value: any = {};\n\n    value.channel_id = this.readUint64(\"big_endian\");\n    value.subchannel_id = {};\n    value.subchannel_id.present = this.readUint8();\n    if (value.subchannel_id.present == 1) {\n      value.subchannel_id.value = this.readUint64(\"big_endian\");\n    }\n    value.parent_id = {};\n    value.parent_id.present = this.readUint8();\n    if (value.parent_id.present == 1) {\n      value.parent_id.value = this.readUint64(\"big_endian\");\n    }\n    const content_length = this.readUint16(\"big_endian\");\n    const content_bytes: number[] = [];\n    for (let i = 0; i < content_length; i++) {\n      content_bytes.push(this.readUint8());\n    }\n    value.content = new TextDecoder().decode(new Uint8Array(content_bytes));\n    return value;\n  }\n}\n\n/**\n * Message post confirmation\n */\nexport interface MessagePosted {\n  success: number;\n  message_id: bigint;\n  message: String;\n}\n\nexport class MessagePostedEncoder extends BitStreamEncoder {\n  private compressionDict: Map<string, number> = new Map();\n\n  constructor() {\n    super(\"msb_first\");\n  }\n\n  encode(value: MessagePosted): Uint8Array {\n    // Reset compression dictionary for each encode\n    this.compressionDict.clear();\n\n    this.writeUint8(value.success);\n    this.writeUint64(value.message_id, \"big_endian\");\n    const value_message_bytes = new TextEncoder().encode(value.message);\n    this.writeUint16(value_message_bytes.length, \"big_endian\");\n    for (const byte of value_message_bytes) {\n      this.writeUint8(byte);\n    }\n    return this.finish();\n  }\n}\n\nexport class MessagePostedDecoder extends BitStreamDecoder {\n  constructor(bytes: Uint8Array | number[], private context?: any) {\n    super(bytes, \"msb_first\");\n  }\n\n  decode(): MessagePosted {\n    const value: any = {};\n\n    value.success = this.readUint8();\n    value.message_id = this.readUint64(\"big_endian\");\n    const message_length = this.readUint16(\"big_endian\");\n    const message_bytes: number[] = [];\n    for (let i = 0; i < message_length; i++) {\n      message_bytes.push(this.readUint8());\n    }\n    value.message = new TextDecoder().decode(new Uint8Array(message_bytes));\n    return value;\n  }\n}\n\n/**\n * Real-time message notification\n */\nexport interface NewMessage {\n  message_id: bigint;\n  channel_id: bigint;\n  subchannel_id: { present: number, value?: bigint };\n  parent_id: { present: number, value?: bigint };\n  author_user_id: { present: number, value?: bigint };\n  author_nickname: String;\n  content: String;\n  created_at: bigint;\n  edited_at: { present: number, value?: bigint };\n  reply_count: number;\n}\n\nexport class NewMessageEncoder extends BitStreamEncoder {\n  private compressionDict: Map<string, number> = new Map();\n\n  constructor() {\n    super(\"msb_first\");\n  }\n\n  encode(value: NewMessage): Uint8Array {\n    // Reset compression dictionary for each encode\n    this.compressionDict.clear();\n\n    this.writeUint64(value.message_id, \"big_endian\");\n    this.writeUint64(value.channel_id, \"big_endian\");\n    this.writeUint8(value.subchannel_id.present);\n    if (value.subchannel_id.present == 1 && value.subchannel_id.value !== undefined) {\n      this.writeUint64(value.subchannel_id.value, \"big_endian\");\n    }\n    this.writeUint8(value.parent_id.present);\n    if (value.parent_id.present == 1 && value.parent_id.value !== undefined) {\n      this.writeUint64(value.parent_id.value, \"big_endian\");\n    }\n    this.writeUint8(value.author_user_id.present);\n    if (value.author_user_id.present == 1 && value.author_user_id.value !== undefined) {\n      this.writeUint64(value.author_user_id.value, \"big_endian\");\n    }\n    const value_author_nickname_bytes = new TextEncoder().encode(value.author_nickname);\n    this.writeUint16(value_author_nickname_bytes.length, \"big_endian\");\n    for (const byte of value_author_nickname_bytes) {\n      this.writeUint8(byte);\n    }\n    const value_content_bytes = new TextEncoder().encode(value.content);\n    this.writeUint16(value_content_bytes.length, \"big_endian\");\n    for (const byte of value_content_bytes) {\n      this.writeUint8(byte);\n    }\n    this.writeInt64(value.created_at, \"big_endian\");\n    this.writeUint8(value.edited_at.present);\n    if (value.edited_at.present == 1 && value.edited_at.value !== undefined) {\n      this.writeInt64(value.edited_at.value, \"big_endian\");\n    }\n    this.writeUint32(value.reply_count, \"big_endian\");\n    return this.finish();\n  }\n}\n\nexport class NewMessageDecoder extends BitStreamDecoder {\n  constructor(bytes: Uint8Array | number[], private context?: any) {\n    super(bytes, \"msb_first\");\n  }\n\n  decode(): NewMessage {\n    const value: any = {};\n\n    value.message_id = this.readUint64(\"big_endian\");\n    value.channel_id = this.readUint64(\"big_endian\");\n    value.subchannel_id = {};\n    value.subchannel_id.present = this.readUint8();\n    if (value.subchannel_id.present == 1) {\n      value.subchannel_id.value = this.readUint64(\"big_endian\");\n    }\n    value.parent_id = {};\n    value.parent_id.present = this.readUint8();\n    if (value.parent_id.present == 1) {\n      value.parent_id.value = this.readUint64(\"big_endian\");\n    }\n    value.author_user_id = {};\n    value.author_user_id.present = this.readUint8();\n    if (value.author_user_id.present == 1) {\n      value.author_user_id.value = this.readUint64(\"big_endian\");\n    }\n    const author_nickname_length = this.readUint16(\"big_endian\");\n    const author_nickname_bytes: number[] = [];\n    for (let i = 0; i < author_nickname_length; i++) {\n      author_nickname_bytes.push(this.readUint8());\n    }\n    value.author_nickname = new TextDecoder().decode(new Uint8Array(author_nickname_bytes));\n    const content_length = this.readUint16(\"big_endian\");\n    const content_bytes: number[] = [];\n    for (let i = 0; i < content_length; i++) {\n      content_bytes.push(this.readUint8());\n    }\n    value.content = new TextDecoder().decode(new Uint8Array(content_bytes));\n    value.created_at = this.readInt64(\"big_endian\");\n    value.edited_at = {};\n    value.edited_at.present = this.readUint8();\n    if (value.edited_at.present == 1) {\n      value.edited_at.value = this.readInt64(\"big_endian\");\n    }\n    value.reply_count = this.readUint32(\"big_endian\");\n    return value;\n  }\n}\n\n/**\n * Register current nickname with password\n */\nexport interface RegisterUser {\n  password_hash: String;\n}\n\nexport class RegisterUserEncoder extends BitStreamEncoder {\n  private compressionDict: Map<string, number> = new Map();\n\n  constructor() {\n    super(\"msb_first\");\n  }\n\n  encode(value: RegisterUser): Uint8Array {\n    // Reset compression dictionary for each encode\n    this.compressionDict.clear();\n\n    const value_password_hash_bytes = new TextEncoder().encode(value.password_hash);\n    this.writeUint16(value_password_hash_bytes.length, \"big_endian\");\n    for (const byte of value_password_hash_bytes) {\n      this.writeUint8(byte);\n    }\n    return this.finish();\n  }\n}\n\nexport class RegisterUserDecoder extends BitStreamDecoder {\n  constructor(bytes: Uint8Array | number[], private context?: any) {\n    super(bytes, \"msb_first\");\n  }\n\n  decode(): RegisterUser {\n    const value: any = {};\n\n    const password_hash_length = this.readUint16(\"big_endian\");\n    const password_hash_bytes: number[] = [];\n    for (let i = 0; i < password_hash_length; i++) {\n      password_hash_bytes.push(this.readUint8());\n    }\n    value.password_hash = new TextDecoder().decode(new Uint8Array(password_hash_bytes));\n    return value;\n  }\n}\n\n/**\n * Registration result\n */\nexport interface RegisterResponse {\n  success: number;\n  user_id: { present: number, value?: bigint };\n}\n\nexport class RegisterResponseEncoder extends BitStreamEncoder {\n  private compressionDict: Map<string, number> = new Map();\n\n  constructor() {\n    super(\"msb_first\");\n  }\n\n  encode(value: RegisterResponse): Uint8Array {\n    // Reset compression dictionary for each encode\n    this.compressionDict.clear();\n\n    this.writeUint8(value.success);\n    this.writeUint8(value.user_id.present);\n    if (value.user_id.present == 1 && value.user_id.value !== undefined) {\n      this.writeUint64(value.user_id.value, \"big_endian\");\n    }\n    return this.finish();\n  }\n}\n\nexport class RegisterResponseDecoder extends BitStreamDecoder {\n  constructor(bytes: Uint8Array | number[], private context?: any) {\n    super(bytes, \"msb_first\");\n  }\n\n  decode(): RegisterResponse {\n    const value: any = {};\n\n    value.success = this.readUint8();\n    value.user_id = {};\n    value.user_id.present = this.readUint8();\n    if (value.user_id.present == 1) {\n      value.user_id.value = this.readUint64(\"big_endian\");\n    }\n    return value;\n  }\n}\n\n/**\n * Request channel list\n */\nexport interface ListChannels {\n  from_channel_id: bigint;\n  limit: number;\n}\n\nexport class ListChannelsEncoder extends BitStreamEncoder {\n  private compressionDict: Map<string, number> = new Map();\n\n  constructor() {\n    super(\"msb_first\");\n  }\n\n  encode(value: ListChannels): Uint8Array {\n    // Reset compression dictionary for each encode\n    this.compressionDict.clear();\n\n    this.writeUint64(value.from_channel_id, \"big_endian\");\n    this.writeUint16(value.limit, \"big_endian\");\n    return this.finish();\n  }\n}\n\nexport class ListChannelsDecoder extends BitStreamDecoder {\n  constructor(bytes: Uint8Array | number[], private context?: any) {\n    super(bytes, \"msb_first\");\n  }\n\n  decode(): ListChannels {\n    const value: any = {};\n\n    value.from_channel_id = this.readUint64(\"big_endian\");\n    value.limit = this.readUint16(\"big_endian\");\n    return value;\n  }\n}\n\n/**\n * Channel information in list\n */\nexport interface Channel {\n  channel_id: bigint;\n  name: String;\n  description: String;\n  user_count: number;\n  is_operator: number;\n  type: number;\n  retention_hours: number;\n}\n\nexport class ChannelEncoder extends BitStreamEncoder {\n  private compressionDict: Map<string, number> = new Map();\n\n  constructor() {\n    super(\"msb_first\");\n  }\n\n  encode(value: Channel): Uint8Array {\n    // Reset compression dictionary for each encode\n    this.compressionDict.clear();\n\n    this.writeUint64(value.channel_id, \"big_endian\");\n    const value_name_bytes = new TextEncoder().encode(value.name);\n    this.writeUint16(value_name_bytes.length, \"big_endian\");\n    for (const byte of value_name_bytes) {\n      this.writeUint8(byte);\n    }\n    const value_description_bytes = new TextEncoder().encode(value.description);\n    this.writeUint16(value_description_bytes.length, \"big_endian\");\n    for (const byte of value_description_bytes) {\n      this.writeUint8(byte);\n    }\n    this.writeUint32(value.user_count, \"big_endian\");\n    this.writeUint8(value.is_operator);\n    this.writeUint8(value.type);\n    this.writeUint32(value.retention_hours, \"big_endian\");\n    return this.finish();\n  }\n}\n\nexport class ChannelDecoder extends BitStreamDecoder {\n  constructor(bytes: Uint8Array | number[], private context?: any) {\n    super(bytes, \"msb_first\");\n  }\n\n  decode(): Channel {\n    const value: any = {};\n\n    value.channel_id = this.readUint64(\"big_endian\");\n    const name_length = this.readUint16(\"big_endian\");\n    const name_bytes: number[] = [];\n    for (let i = 0; i < name_length; i++) {\n      name_bytes.push(this.readUint8());\n    }\n    value.name = new TextDecoder().decode(new Uint8Array(name_bytes));\n    const description_length = this.readUint16(\"big_endian\");\n    const description_bytes: number[] = [];\n    for (let i = 0; i < description_length; i++) {\n      description_bytes.push(this.readUint8());\n    }\n    value.description = new TextDecoder().decode(new Uint8Array(description_bytes));\n    value.user_count = this.readUint32(\"big_endian\");\n    value.is_operator = this.readUint8();\n    value.type = this.readUint8();\n    value.retention_hours = this.readUint32(\"big_endian\");\n    return value;\n  }\n}\n\n/**\n * List of channels\n */\nexport interface ChannelList {\n  channel_count: number;\n  channels: Channel[];\n}\n\nexport class ChannelListEncoder extends BitStreamEncoder {\n  private compressionDict: Map<string, number> = new Map();\n\n  constructor() {\n    super(\"msb_first\");\n  }\n\n  encode(value: ChannelList): Uint8Array {\n    // Reset compression dictionary for each encode\n    this.compressionDict.clear();\n\n    this.writeUint16(value.channel_count, \"big_endian\");\n    for (const value_channels_item of value.channels) {\n      this.writeUint64(value_channels_item.channel_id, \"big_endian\");\n      const value_channels_item_name_bytes = new TextEncoder().encode(value_channels_item.name);\n      this.writeUint16(value_channels_item_name_bytes.length, \"big_endian\");\n      for (const byte of value_channels_item_name_bytes) {\n        this.writeUint8(byte);\n      }\n      const value_channels_item_description_bytes = new TextEncoder().encode(value_channels_item.description);\n      this.writeUint16(value_channels_item_description_bytes.length, \"big_endian\");\n      for (const byte of value_channels_item_description_bytes) {\n        this.writeUint8(byte);\n      }\n      this.writeUint32(value_channels_item.user_count, \"big_endian\");\n      this.writeUint8(value_channels_item.is_operator);\n      this.writeUint8(value_channels_item.type);\n      this.writeUint32(value_channels_item.retention_hours, \"big_endian\");\n    }\n    return this.finish();\n  }\n}\n\nexport class ChannelListDecoder extends BitStreamDecoder {\n  constructor(bytes: Uint8Array | number[], private context?: any) {\n    super(bytes, \"msb_first\");\n  }\n\n  decode(): ChannelList {\n    const value: any = {};\n\n    value.channel_count = this.readUint16(\"big_endian\");\n    value.channels = [];\n    const channels_length = value.channel_count ?? this.context?.channel_count;\n    if (channels_length === undefined) {\n      throw new Error('Field-referenced array length field \"channel_count\" not found in value or context');\n    }\n    for (let i = 0; i < channels_length; i++) {\n      let channels_item: any;\n      channels_item = {};\n      channels_item.channel_id = this.readUint64(\"big_endian\");\n      const channels_item_name_length = this.readUint16(\"big_endian\");\n      const channels_item_name_bytes: number[] = [];\n      for (let i = 0; i < channels_item_name_length; i++) {\n        channels_item_name_bytes.push(this.readUint8());\n      }\n      channels_item.name = new TextDecoder().decode(new Uint8Array(channels_item_name_bytes));\n      const channels_item_description_length = this.readUint16(\"big_endian\");\n      const channels_item_description_bytes: number[] = [];\n      for (let i = 0; i < channels_item_description_length; i++) {\n        channels_item_description_bytes.push(this.readUint8());\n      }\n      channels_item.description = new TextDecoder().decode(new Uint8Array(channels_item_description_bytes));\n      channels_item.user_count = this.readUint32(\"big_endian\");\n      channels_item.is_operator = this.readUint8();\n      channels_item.type = this.readUint8();\n      channels_item.retention_hours = this.readUint32(\"big_endian\");\n      value.channels.push(channels_item);\n    }\n    return value;\n  }\n}\n\n/**\n * Join a channel\n */\nexport interface JoinChannel {\n  channel_id: bigint;\n  subchannel_id: { present: number, value?: bigint };\n}\n\nexport class JoinChannelEncoder extends BitStreamEncoder {\n  private compressionDict: Map<string, number> = new Map();\n\n  constructor() {\n    super(\"msb_first\");\n  }\n\n  encode(value: JoinChannel): Uint8Array {\n    // Reset compression dictionary for each encode\n    this.compressionDict.clear();\n\n    this.writeUint64(value.channel_id, \"big_endian\");\n    this.writeUint8(value.subchannel_id.present);\n    if (value.subchannel_id.present == 1 && value.subchannel_id.value !== undefined) {\n      this.writeUint64(value.subchannel_id.value, \"big_endian\");\n    }\n    return this.finish();\n  }\n}\n\nexport class JoinChannelDecoder extends BitStreamDecoder {\n  constructor(bytes: Uint8Array | number[], private context?: any) {\n    super(bytes, \"msb_first\");\n  }\n\n  decode(): JoinChannel {\n    const value: any = {};\n\n    value.channel_id = this.readUint64(\"big_endian\");\n    value.subchannel_id = {};\n    value.subchannel_id.present = this.readUint8();\n    if (value.subchannel_id.present == 1) {\n      value.subchannel_id.value = this.readUint64(\"big_endian\");\n    }\n    return value;\n  }\n}\n\n/**\n * Join result\n */\nexport interface JoinResponse {\n  success: number;\n  channel_id: bigint;\n  subchannel_id: { present: number, value?: bigint };\n  message: String;\n}\n\nexport class JoinResponseEncoder extends BitStreamEncoder {\n  private compressionDict: Map<string, number> = new Map();\n\n  constructor() {\n    super(\"msb_first\");\n  }\n\n  encode(value: JoinResponse): Uint8Array {\n    // Reset compression dictionary for each encode\n    this.compressionDict.clear();\n\n    this.writeUint8(value.success);\n    this.writeUint64(value.channel_id, \"big_endian\");\n    this.writeUint8(value.subchannel_id.present);\n    if (value.subchannel_id.present == 1 && value.subchannel_id.value !== undefined) {\n      this.writeUint64(value.subchannel_id.value, \"big_endian\");\n    }\n    const value_message_bytes = new TextEncoder().encode(value.message);\n    this.writeUint16(value_message_bytes.length, \"big_endian\");\n    for (const byte of value_message_bytes) {\n      this.writeUint8(byte);\n    }\n    return this.finish();\n  }\n}\n\nexport class JoinResponseDecoder extends BitStreamDecoder {\n  constructor(bytes: Uint8Array | number[], private context?: any) {\n    super(bytes, \"msb_first\");\n  }\n\n  decode(): JoinResponse {\n    const value: any = {};\n\n    value.success = this.readUint8();\n    value.channel_id = this.readUint64(\"big_endian\");\n    value.subchannel_id = {};\n    value.subchannel_id.present = this.readUint8();\n    if (value.subchannel_id.present == 1) {\n      value.subchannel_id.value = this.readUint64(\"big_endian\");\n    }\n    const message_length = this.readUint16(\"big_endian\");\n    const message_bytes: number[] = [];\n    for (let i = 0; i < message_length; i++) {\n      message_bytes.push(this.readUint8());\n    }\n    value.message = new TextDecoder().decode(new Uint8Array(message_bytes));\n    return value;\n  }\n}\n\n/**\n * Request messages from channel\n */\nexport interface ListMessages {\n  channel_id: bigint;\n  subchannel_id: { present: number, value?: bigint };\n  limit: number;\n  before_id: { present: number, value?: bigint };\n  parent_id: { present: number, value?: bigint };\n  after_id: { present: number, value?: bigint };\n}\n\nexport class ListMessagesEncoder extends BitStreamEncoder {\n  private compressionDict: Map<string, number> = new Map();\n\n  constructor() {\n    super(\"msb_first\");\n  }\n\n  encode(value: ListMessages): Uint8Array {\n    // Reset compression dictionary for each encode\n    this.compressionDict.clear();\n\n    this.writeUint64(value.channel_id, \"big_endian\");\n    this.writeUint8(value.subchannel_id.present);\n    if (value.subchannel_id.present == 1 && value.subchannel_id.value !== undefined) {\n      this.writeUint64(value.subchannel_id.value, \"big_endian\");\n    }\n    this.writeUint16(value.limit, \"big_endian\");\n    this.writeUint8(value.before_id.present);\n    if (value.before_id.present == 1 && value.before_id.value !== undefined) {\n      this.writeUint64(value.before_id.value, \"big_endian\");\n    }\n    this.writeUint8(value.parent_id.present);\n    if (value.parent_id.present == 1 && value.parent_id.value !== undefined) {\n      this.writeUint64(value.parent_id.value, \"big_endian\");\n    }\n    this.writeUint8(value.after_id.present);\n    if (value.after_id.present == 1 && value.after_id.value !== undefined) {\n      this.writeUint64(value.after_id.value, \"big_endian\");\n    }\n    return this.finish();\n  }\n}\n\nexport class ListMessagesDecoder extends BitStreamDecoder {\n  constructor(bytes: Uint8Array | number[], private context?: any) {\n    super(bytes, \"msb_first\");\n  }\n\n  decode(): ListMessages {\n    const value: any = {};\n\n    value.channel_id = this.readUint64(\"big_endian\");\n    value.subchannel_id = {};\n    value.subchannel_id.present = this.readUint8();\n    if (value.subchannel_id.present == 1) {\n      value.subchannel_id.value = this.readUint64(\"big_endian\");\n    }\n    value.limit = this.readUint16(\"big_endian\");\n    value.before_id = {};\n    value.before_id.present = this.readUint8();\n    if (value.before_id.present == 1) {\n      value.before_id.value = this.readUint64(\"big_endian\");\n    }\n    value.parent_id = {};\n    value.parent_id.present = this.readUint8();\n    if (value.parent_id.present == 1) {\n      value.parent_id.value = this.readUint64(\"big_endian\");\n    }\n    value.after_id = {};\n    value.after_id.present = this.readUint8();\n    if (value.after_id.present == 1) {\n      value.after_id.value = this.readUint64(\"big_endian\");\n    }\n    return value;\n  }\n}\n\n/**\n * Message in list\n */\nexport interface Message {\n  message_id: bigint;\n  channel_id: bigint;\n  subchannel_id: { present: number, value?: bigint };\n  parent_id: { present: number, value?: bigint };\n  author_user_id: { present: number, value?: bigint };\n  author_nickname: String;\n  content: String;\n  created_at: bigint;\n  edited_at: { present: number, value?: bigint };\n  reply_count: number;\n}\n\nexport class MessageEncoder extends BitStreamEncoder {\n  private compressionDict: Map<string, number> = new Map();\n\n  constructor() {\n    super(\"msb_first\");\n  }\n\n  encode(value: Message): Uint8Array {\n    // Reset compression dictionary for each encode\n    this.compressionDict.clear();\n\n    this.writeUint64(value.message_id, \"big_endian\");\n    this.writeUint64(value.channel_id, \"big_endian\");\n    this.writeUint8(value.subchannel_id.present);\n    if (value.subchannel_id.present == 1 && value.subchannel_id.value !== undefined) {\n      this.writeUint64(value.subchannel_id.value, \"big_endian\");\n    }\n    this.writeUint8(value.parent_id.present);\n    if (value.parent_id.present == 1 && value.parent_id.value !== undefined) {\n      this.writeUint64(value.parent_id.value, \"big_endian\");\n    }\n    this.writeUint8(value.author_user_id.present);\n    if (value.author_user_id.present == 1 && value.author_user_id.value !== undefined) {\n      this.writeUint64(value.author_user_id.value, \"big_endian\");\n    }\n    const value_author_nickname_bytes = new TextEncoder().encode(value.author_nickname);\n    this.writeUint16(value_author_nickname_bytes.length, \"big_endian\");\n    for (const byte of value_author_nickname_bytes) {\n      this.writeUint8(byte);\n    }\n    const value_content_bytes = new TextEncoder().encode(value.content);\n    this.writeUint16(value_content_bytes.length, \"big_endian\");\n    for (const byte of value_content_bytes) {\n      this.writeUint8(byte);\n    }\n    this.writeInt64(value.created_at, \"big_endian\");\n    this.writeUint8(value.edited_at.present);\n    if (value.edited_at.present == 1 && value.edited_at.value !== undefined) {\n      this.writeInt64(value.edited_at.value, \"big_endian\");\n    }\n    this.writeUint32(value.reply_count, \"big_endian\");\n    return this.finish();\n  }\n}\n\nexport class MessageDecoder extends BitStreamDecoder {\n  constructor(bytes: Uint8Array | number[], private context?: any) {\n    super(bytes, \"msb_first\");\n  }\n\n  decode(): Message {\n    const value: any = {};\n\n    value.message_id = this.readUint64(\"big_endian\");\n    value.channel_id = this.readUint64(\"big_endian\");\n    value.subchannel_id = {};\n    value.subchannel_id.present = this.readUint8();\n    if (value.subchannel_id.present == 1) {\n      value.subchannel_id.value = this.readUint64(\"big_endian\");\n    }\n    value.parent_id = {};\n    value.parent_id.present = this.readUint8();\n    if (value.parent_id.present == 1) {\n      value.parent_id.value = this.readUint64(\"big_endian\");\n    }\n    value.author_user_id = {};\n    value.author_user_id.present = this.readUint8();\n    if (value.author_user_id.present == 1) {\n      value.author_user_id.value = this.readUint64(\"big_endian\");\n    }\n    const author_nickname_length = this.readUint16(\"big_endian\");\n    const author_nickname_bytes: number[] = [];\n    for (let i = 0; i < author_nickname_length; i++) {\n      author_nickname_bytes.push(this.readUint8());\n    }\n    value.author_nickname = new TextDecoder().decode(new Uint8Array(author_nickname_bytes));\n    const content_length = this.readUint16(\"big_endian\");\n    const content_bytes: number[] = [];\n    for (let i = 0; i < content_length; i++) {\n      content_bytes.push(this.readUint8());\n    }\n    value.content = new TextDecoder().decode(new Uint8Array(content_bytes));\n    value.created_at = this.readInt64(\"big_endian\");\n    value.edited_at = {};\n    value.edited_at.present = this.readUint8();\n    if (value.edited_at.present == 1) {\n      value.edited_at.value = this.readInt64(\"big_endian\");\n    }\n    value.reply_count = this.readUint32(\"big_endian\");\n    return value;\n  }\n}\n\n/**\n * List of messages\n */\nexport interface MessageList {\n  channel_id: bigint;\n  subchannel_id: { present: number, value?: bigint };\n  parent_id: { present: number, value?: bigint };\n  message_count: number;\n  messages: Message[];\n}\n\nexport class MessageListEncoder extends BitStreamEncoder {\n  private compressionDict: Map<string, number> = new Map();\n\n  constructor() {\n    super(\"msb_first\");\n  }\n\n  encode(value: MessageList): Uint8Array {\n    // Reset compression dictionary for each encode\n    this.compressionDict.clear();\n\n    this.writeUint64(value.channel_id, \"big_endian\");\n    this.writeUint8(value.subchannel_id.present);\n    if (value.subchannel_id.present == 1 && value.subchannel_id.value !== undefined) {\n      this.writeUint64(value.subchannel_id.value, \"big_endian\");\n    }\n    this.writeUint8(value.parent_id.present);\n    if (value.parent_id.present == 1 && value.parent_id.value !== undefined) {\n      this.writeUint64(value.parent_id.value, \"big_endian\");\n    }\n    this.writeUint16(value.message_count, \"big_endian\");\n    for (const value_messages_item of value.messages) {\n      this.writeUint64(value_messages_item.message_id, \"big_endian\");\n      this.writeUint64(value_messages_item.channel_id, \"big_endian\");\n      this.writeUint8(value_messages_item.subchannel_id.present);\n      if (value_messages_item.subchannel_id.present == 1 && value_messages_item.subchannel_id.value !== undefined) {\n        this.writeUint64(value_messages_item.subchannel_id.value, \"big_endian\");\n      }\n      this.writeUint8(value_messages_item.parent_id.present);\n      if (value_messages_item.parent_id.present == 1 && value_messages_item.parent_id.value !== undefined) {\n        this.writeUint64(value_messages_item.parent_id.value, \"big_endian\");\n      }\n      this.writeUint8(value_messages_item.author_user_id.present);\n      if (value_messages_item.author_user_id.present == 1 && value_messages_item.author_user_id.value !== undefined) {\n        this.writeUint64(value_messages_item.author_user_id.value, \"big_endian\");\n      }\n      const value_messages_item_author_nickname_bytes = new TextEncoder().encode(value_messages_item.author_nickname);\n      this.writeUint16(value_messages_item_author_nickname_bytes.length, \"big_endian\");\n      for (const byte of value_messages_item_author_nickname_bytes) {\n        this.writeUint8(byte);\n      }\n      const value_messages_item_content_bytes = new TextEncoder().encode(value_messages_item.content);\n      this.writeUint16(value_messages_item_content_bytes.length, \"big_endian\");\n      for (const byte of value_messages_item_content_bytes) {\n        this.writeUint8(byte);\n      }\n      this.writeInt64(value_messages_item.created_at, \"big_endian\");\n      this.writeUint8(value_messages_item.edited_at.present);\n      if (value_messages_item.edited_at.present == 1 && value_messages_item.edited_at.value !== undefined) {\n        this.writeInt64(value_messages_item.edited_at.value, \"big_endian\");\n      }\n      this.writeUint32(value_messages_item.reply_count, \"big_endian\");\n    }\n    return this.finish();\n  }\n}\n\nexport class MessageListDecoder extends BitStreamDecoder {\n  constructor(bytes: Uint8Array | number[], private context?: any) {\n    super(bytes, \"msb_first\");\n  }\n\n  decode(): MessageList {\n    const value: any = {};\n\n    value.channel_id = this.readUint64(\"big_endian\");\n    value.subchannel_id = {};\n    value.subchannel_id.present = this.readUint8();\n    if (value.subchannel_id.present == 1) {\n      value.subchannel_id.value = this.readUint64(\"big_endian\");\n    }\n    value.parent_id = {};\n    value.parent_id.present = this.readUint8();\n    if (value.parent_id.present == 1) {\n      value.parent_id.value = this.readUint64(\"big_endian\");\n    }\n    value.message_count = this.readUint16(\"big_endian\");\n    value.messages = [];\n    const messages_length = value.message_count ?? this.context?.message_count;\n    if (messages_length === undefined) {\n      throw new Error('Field-referenced array length field \"message_count\" not found in value or context');\n    }\n    for (let i = 0; i < messages_length; i++) {\n      let messages_item: any;\n      messages_item = {};\n      messages_item.message_id = this.readUint64(\"big_endian\");\n      messages_item.channel_id = this.readUint64(\"big_endian\");\n      messages_item.subchannel_id = {};\n      messages_item.subchannel_id.present = this.readUint8();\n      if (messages_item.subchannel_id.present == 1) {\n        messages_item.subchannel_id.value = this.readUint64(\"big_endian\");\n      }\n      messages_item.parent_id = {};\n      messages_item.parent_id.present = this.readUint8();\n      if (messages_item.parent_id.present == 1) {\n        messages_item.parent_id.value = this.readUint64(\"big_endian\");\n      }\n      messages_item.author_user_id = {};\n      messages_item.author_user_id.present = this.readUint8();\n      if (messages_item.author_user_id.present == 1) {\n        messages_item.author_user_id.value = this.readUint64(\"big_endian\");\n      }\n      const messages_item_author_nickname_length = this.readUint16(\"big_endian\");\n      const messages_item_author_nickname_bytes: number[] = [];\n      for (let i = 0; i < messages_item_author_nickname_length; i++) {\n        messages_item_author_nickname_bytes.push(this.readUint8());\n      }\n      messages_item.author_nickname = new TextDecoder().decode(new Uint8Array(messages_item_author_nickname_bytes));\n      const messages_item_content_length = this.readUint16(\"big_endian\");\n      const messages_item_content_bytes: number[] = [];\n      for (let i = 0; i < messages_item_content_length; i++) {\n        messages_item_content_bytes.push(this.readUint8());\n      }\n      messages_item.content = new TextDecoder().decode(new Uint8Array(messages_item_content_bytes));\n      messages_item.created_at = this.readInt64(\"big_endian\");\n      messages_item.edited_at = {};\n      messages_item.edited_at.present = this.readUint8();\n      if (messages_item.edited_at.present == 1) {\n        messages_item.edited_at.value = this.readInt64(\"big_endian\");\n      }\n      messages_item.reply_count = this.readUint32(\"big_endian\");\n      value.messages.push(messages_item);\n    }\n    return value;\n  }\n}\n\n/**\n * Keepalive heartbeat\n */\nexport interface Ping {\n  timestamp: bigint;\n}\n\nexport class PingEncoder extends BitStreamEncoder {\n  private compressionDict: Map<string, number> = new Map();\n\n  constructor() {\n    super(\"msb_first\");\n  }\n\n  encode(value: Ping): Uint8Array {\n    // Reset compression dictionary for each encode\n    this.compressionDict.clear();\n\n    this.writeInt64(value.timestamp, \"big_endian\");\n    return this.finish();\n  }\n}\n\nexport class PingDecoder extends BitStreamDecoder {\n  constructor(bytes: Uint8Array | number[], private context?: any) {\n    super(bytes, \"msb_first\");\n  }\n\n  decode(): Ping {\n    const value: any = {};\n\n    value.timestamp = this.readInt64(\"big_endian\");\n    return value;\n  }\n}\n\n/**\n * Ping response\n */\nexport interface Pong {\n  client_timestamp: bigint;\n}\n\nexport class PongEncoder extends BitStreamEncoder {\n  private compressionDict: Map<string, number> = new Map();\n\n  constructor() {\n    super(\"msb_first\");\n  }\n\n  encode(value: Pong): Uint8Array {\n    // Reset compression dictionary for each encode\n    this.compressionDict.clear();\n\n    this.writeInt64(value.client_timestamp, \"big_endian\");\n    return this.finish();\n  }\n}\n\nexport class PongDecoder extends BitStreamDecoder {\n  constructor(bytes: Uint8Array | number[], private context?: any) {\n    super(bytes, \"msb_first\");\n  }\n\n  decode(): Pong {\n    const value: any = {};\n\n    value.client_timestamp = this.readInt64(\"big_endian\");\n    return value;\n  }\n}\n\n/**\n * Subscribe to thread updates\n */\nexport interface SubscribeThread {\n  thread_id: bigint;\n}\n\nexport class SubscribeThreadEncoder extends BitStreamEncoder {\n  private compressionDict: Map<string, number> = new Map();\n\n  constructor() {\n    super(\"msb_first\");\n  }\n\n  encode(value: SubscribeThread): Uint8Array {\n    // Reset compression dictionary for each encode\n    this.compressionDict.clear();\n\n    this.writeUint64(value.thread_id, \"big_endian\");\n    return this.finish();\n  }\n}\n\nexport class SubscribeThreadDecoder extends BitStreamDecoder {\n  constructor(bytes: Uint8Array | number[], private context?: any) {\n    super(bytes, \"msb_first\");\n  }\n\n  decode(): SubscribeThread {\n    const value: any = {};\n\n    value.thread_id = this.readUint64(\"big_endian\");\n    return value;\n  }\n}\n\n/**\n * Unsubscribe from thread updates\n */\nexport interface UnsubscribeThread {\n  thread_id: bigint;\n}\n\nexport class UnsubscribeThreadEncoder extends BitStreamEncoder {\n  private compressionDict: Map<string, number> = new Map();\n\n  constructor() {\n    super(\"msb_first\");\n  }\n\n  encode(value: UnsubscribeThread): Uint8Array {\n    // Reset compression dictionary for each encode\n    this.compressionDict.clear();\n\n    this.writeUint64(value.thread_id, \"big_endian\");\n    return this.finish();\n  }\n}\n\nexport class UnsubscribeThreadDecoder extends BitStreamDecoder {\n  constructor(bytes: Uint8Array | number[], private context?: any) {\n    super(bytes, \"msb_first\");\n  }\n\n  decode(): UnsubscribeThread {\n    const value: any = {};\n\n    value.thread_id = this.readUint64(\"big_endian\");\n    return value;\n  }\n}\n\n/**\n * Subscribe to new threads in channel\n */\nexport interface SubscribeChannel {\n  channel_id: bigint;\n  subchannel_id: { present: number, value?: bigint };\n}\n\nexport class SubscribeChannelEncoder extends BitStreamEncoder {\n  private compressionDict: Map<string, number> = new Map();\n\n  constructor() {\n    super(\"msb_first\");\n  }\n\n  encode(value: SubscribeChannel): Uint8Array {\n    // Reset compression dictionary for each encode\n    this.compressionDict.clear();\n\n    this.writeUint64(value.channel_id, \"big_endian\");\n    this.writeUint8(value.subchannel_id.present);\n    if (value.subchannel_id.present == 1 && value.subchannel_id.value !== undefined) {\n      this.writeUint64(value.subchannel_id.value, \"big_endian\");\n    }\n    return this.finish();\n  }\n}\n\nexport class SubscribeChannelDecoder extends BitStreamDecoder {\n  constructor(bytes: Uint8Array | number[], private context?: any) {\n    super(bytes, \"msb_first\");\n  }\n\n  decode(): SubscribeChannel {\n    const value: any = {};\n\n    value.channel_id = this.readUint64(\"big_endian\");\n    value.subchannel_id = {};\n    value.subchannel_id.present = this.readUint8();\n    if (value.subchannel_id.present == 1) {\n      value.subchannel_id.value = this.readUint64(\"big_endian\");\n    }\n    return value;\n  }\n}\n\n/**\n * Unsubscribe from channel updates\n */\nexport interface UnsubscribeChannel {\n  channel_id: bigint;\n  subchannel_id: { present: number, value?: bigint };\n}\n\nexport class UnsubscribeChannelEncoder extends BitStreamEncoder {\n  private compressionDict: Map<string, number> = new Map();\n\n  constructor() {\n    super(\"msb_first\");\n  }\n\n  encode(value: UnsubscribeChannel): Uint8Array {\n    // Reset compression dictionary for each encode\n    this.compressionDict.clear();\n\n    this.writeUint64(value.channel_id, \"big_endian\");\n    this.writeUint8(value.subchannel_id.present);\n    if (value.subchannel_id.present == 1 && value.subchannel_id.value !== undefined) {\n      this.writeUint64(value.subchannel_id.value, \"big_endian\");\n    }\n    return this.finish();\n  }\n}\n\nexport class UnsubscribeChannelDecoder extends BitStreamDecoder {\n  constructor(bytes: Uint8Array | number[], private context?: any) {\n    super(bytes, \"msb_first\");\n  }\n\n  decode(): UnsubscribeChannel {\n    const value: any = {};\n\n    value.channel_id = this.readUint64(\"big_endian\");\n    value.subchannel_id = {};\n    value.subchannel_id.present = this.readUint8();\n    if (value.subchannel_id.present == 1) {\n      value.subchannel_id.value = this.readUint64(\"big_endian\");\n    }\n    return value;\n  }\n}\n\n/**\n * Subscription confirmation\n */\nexport interface SubscribeOk {\n  type: number;\n  id: bigint;\n  subchannel_id: { present: number, value?: bigint };\n}\n\nexport class SubscribeOkEncoder extends BitStreamEncoder {\n  private compressionDict: Map<string, number> = new Map();\n\n  constructor() {\n    super(\"msb_first\");\n  }\n\n  encode(value: SubscribeOk): Uint8Array {\n    // Reset compression dictionary for each encode\n    this.compressionDict.clear();\n\n    this.writeUint8(value.type);\n    this.writeUint64(value.id, \"big_endian\");\n    this.writeUint8(value.subchannel_id.present);\n    if (value.subchannel_id.present == 1 && value.subchannel_id.value !== undefined) {\n      this.writeUint64(value.subchannel_id.value, \"big_endian\");\n    }\n    return this.finish();\n  }\n}\n\nexport class SubscribeOkDecoder extends BitStreamDecoder {\n  constructor(bytes: Uint8Array | number[], private context?: any) {\n    super(bytes, \"msb_first\");\n  }\n\n  decode(): SubscribeOk {\n    const value: any = {};\n\n    value.type = this.readUint8();\n    value.id = this.readUint64(\"big_endian\");\n    value.subchannel_id = {};\n    value.subchannel_id.present = this.readUint8();\n    if (value.subchannel_id.present == 1) {\n      value.subchannel_id.value = this.readUint64(\"big_endian\");\n    }\n    return value;\n  }\n}\n\n/**\n * Generic error response\n */\nexport interface Error_ {\n  error_code: number;\n  message: String;\n}\n\nexport class Error_Encoder extends BitStreamEncoder {\n  private compressionDict: Map<string, number> = new Map();\n\n  constructor() {\n    super(\"msb_first\");\n  }\n\n  encode(value: Error_): Uint8Array {\n    // Reset compression dictionary for each encode\n    this.compressionDict.clear();\n\n    this.writeUint16(value.error_code, \"big_endian\");\n    const value_message_bytes = new TextEncoder().encode(value.message);\n    this.writeUint16(value_message_bytes.length, \"big_endian\");\n    for (const byte of value_message_bytes) {\n      this.writeUint8(byte);\n    }\n    return this.finish();\n  }\n}\n\nexport class Error_Decoder extends BitStreamDecoder {\n  constructor(bytes: Uint8Array | number[], private context?: any) {\n    super(bytes, \"msb_first\");\n  }\n\n  decode(): Error_ {\n    const value: any = {};\n\n    value.error_code = this.readUint16(\"big_endian\");\n    const message_length = this.readUint16(\"big_endian\");\n    const message_bytes: number[] = [];\n    for (let i = 0; i < message_length; i++) {\n      message_bytes.push(this.readUint8());\n    }\n    value.message = new TextDecoder().decode(new Uint8Array(message_bytes));\n    return value;\n  }\n}\n\n/**\n * Server configuration and limits\n */\nexport interface ServerConfig {\n  protocol_version: number;\n  max_message_rate: number;\n  max_channel_creates: number;\n  inactive_cleanup_days: number;\n  max_connections_per_ip: number;\n  max_message_length: number;\n  max_thread_subs: number;\n  max_channel_subs: number;\n  directory_enabled: number;\n}\n\nexport class ServerConfigEncoder extends BitStreamEncoder {\n  private compressionDict: Map<string, number> = new Map();\n\n  constructor() {\n    super(\"msb_first\");\n  }\n\n  encode(value: ServerConfig): Uint8Array {\n    // Reset compression dictionary for each encode\n    this.compressionDict.clear();\n\n    this.writeUint8(value.protocol_version);\n    this.writeUint16(value.max_message_rate, \"big_endian\");\n    this.writeUint16(value.max_channel_creates, \"big_endian\");\n    this.writeUint16(value.inactive_cleanup_days, \"big_endian\");\n    this.writeUint8(value.max_connections_per_ip);\n    this.writeUint32(value.max_message_length, \"big_endian\");\n    this.writeUint16(value.max_thread_subs, \"big_endian\");\n    this.writeUint16(value.max_channel_subs, \"big_endian\");\n    this.writeUint8(value.directory_enabled);\n    return this.finish();\n  }\n}\n\nexport class ServerConfigDecoder extends BitStreamDecoder {\n  constructor(bytes: Uint8Array | number[], private context?: any) {\n    super(bytes, \"msb_first\");\n  }\n\n  decode(): ServerConfig {\n    const value: any = {};\n\n    value.protocol_version = this.readUint8();\n    value.max_message_rate = this.readUint16(\"big_endian\");\n    value.max_channel_creates = this.readUint16(\"big_endian\");\n    value.inactive_cleanup_days = this.readUint16(\"big_endian\");\n    value.max_connections_per_ip = this.readUint8();\n    value.max_message_length = this.readUint32(\"big_endian\");\n    value.max_thread_subs = this.readUint16(\"big_endian\");\n    value.max_channel_subs = this.readUint16(\"big_endian\");\n    value.directory_enabled = this.readUint8();\n    return value;\n  }\n}\n\n", "// ABOUTME: SuperChat web client main entry point\n// ABOUTME: Handles WebSocket connection, protocol encoding/decoding, and UI updates\n\nimport {\n  FrameHeaderEncoder, FrameHeaderDecoder,\n  SetNicknameEncoder, NicknameResponseDecoder,\n  ListChannelsEncoder, ChannelListDecoder,\n  JoinChannelEncoder, JoinResponseDecoder,\n  ListMessagesEncoder, MessageListDecoder,\n  PostMessageEncoder, MessagePostedDecoder,\n  NewMessageDecoder,\n  SubscribeThreadEncoder, UnsubscribeThreadEncoder,\n  SubscribeChannelEncoder, UnsubscribeChannelEncoder,\n  SubscribeOkDecoder,\n  ServerConfigDecoder,\n  Error_Decoder,\n  PingEncoder,\n  type SetNickname, type ListChannels, type JoinChannel,\n  type ListMessages, type PostMessage, type Ping,\n  type Channel, type Message, type NewMessage, type SubscribeOk\n} from './SuperChatCodec.js';\n\nimport { BitStreamDecoder } from './BitStream.js';\n\n// View states\nenum ViewState {\n  ThreadList,\n  ThreadDetail\n}\n\n// Protocol message type codes\nconst MSG_SET_NICKNAME = 0x02;\nconst MSG_NICKNAME_RESPONSE = 0x82;\nconst MSG_LIST_CHANNELS = 0x04;\nconst MSG_CHANNEL_LIST = 0x84;\nconst MSG_JOIN_CHANNEL = 0x05;\nconst MSG_JOIN_RESPONSE = 0x85;\nconst MSG_LIST_MESSAGES = 0x09;\nconst MSG_MESSAGE_LIST = 0x89;\nconst MSG_POST_MESSAGE = 0x0A;\nconst MSG_MESSAGE_POSTED = 0x8A;\nconst MSG_NEW_MESSAGE = 0x8D;\nconst MSG_PING = 0x10;\nconst MSG_PONG = 0x90;\nconst MSG_SUBSCRIBE_THREAD = 0x51;\nconst MSG_UNSUBSCRIBE_THREAD = 0x52;\nconst MSG_SUBSCRIBE_CHANNEL = 0x53;\nconst MSG_UNSUBSCRIBE_CHANNEL = 0x54;\nconst MSG_SUBSCRIBE_OK = 0x99;\nconst MSG_CHANNEL_PRESENCE = 0xAC;\nconst MSG_ERROR = 0x91;\nconst MSG_SERVER_CONFIG = 0x98;\n\n// Application state\nclass SuperChatClient {\n  private ws: WebSocket | null = null;\n  private nickname: string = '';\n  private isRegistered: boolean = false; // Track if we're a registered user\n  private currentChannel: Channel | null = null;\n  private channels: Map<bigint, Channel> = new Map();\n  private pingInterval: number | null = null;\n  private frameBuffer: Uint8Array = new Uint8Array(0);\n  private expectedFrameLength: number | null = null;\n\n  // Traffic tracking\n  private bytesSent: number = 0;\n  private bytesReceived: number = 0;\n  private bytesReceivedThrottled: number = 0; // Bytes we've \"received\" according to throttle\n  private trafficUpdateInterval: number | null = null;\n  private throttleBytesPerSecond: number = 0; // 0 = no throttle\n  private pendingSends: Array<{data: Uint8Array, timestamp: number}> = [];\n\n  // Receive throttling (buffer complete frames, not fragments)\n  private frameReceiveBuffer: Array<{frame: Uint8Array, arrivedAt: number, size: number}> = [];\n  private receiveProcessInterval: number | null = null;\n  private lastReceiveProcessTime: number = 0;\n\n  // Threading state\n  private currentView: ViewState = ViewState.ThreadList;\n  private currentThread: Message | null = null;\n  private threads: Message[] = []; // Root messages only (parent_id.present === 0)\n  private threadReplies: Map<bigint, Message[]> = new Map(); // Replies by thread root ID\n  private replyToMessageId: bigint | null = null; // When composing a reply\n  private replyingToMessage: Message | null = null; // Full message being replied to\n\n  // Subscription tracking\n  private subscribedChannelId: bigint | null = null;\n  private subscribedThreadId: bigint | null = null;\n\n  // Server list\n  private servers: Array<{name: string, wsUrl: string, wssUrl: string, status: 'checking' | 'online' | 'offline', isSecure: boolean}> = [];\n  private selectedServerUrl: string = '';\n  private selectedServerIndex: number = -1;\n\n  constructor() {\n    this.setupEventListeners();\n    this.initializeServers();\n  }\n\n  private initializeServers() {\n    const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';\n    const hostname = window.location.hostname || 'localhost';\n\n    this.servers = [\n      {\n        name: 'Current Server',\n        wsUrl: `ws://${hostname}:8080/ws`,\n        wssUrl: `wss://${hostname}:8080/ws`,\n        status: 'checking',\n        isSecure: protocol === 'wss:'\n      }\n    ];\n\n    // Only add superchat.win if we're not already on it\n    if (hostname !== 'superchat.win') {\n      this.servers.push({\n        name: 'superchat.win',\n        wsUrl: 'ws://superchat.win:8080/ws',\n        wssUrl: 'wss://superchat.win:8080/ws',\n        status: 'checking',\n        isSecure: false\n      });\n    }\n\n    // Always add Custom Server last\n    this.servers.push({\n      name: 'Custom Server',\n      wsUrl: '',\n      wssUrl: '',\n      status: 'offline',\n      isSecure: false\n    });\n\n    // Restore last nickname\n    const savedNickname = localStorage.getItem('superchat_nickname');\n    if (savedNickname) {\n      const nicknameInput = document.getElementById('nickname') as HTMLInputElement;\n      if (nicknameInput) {\n        nicknameInput.value = savedNickname;\n      }\n    }\n\n    // Restore last selected server\n    const savedServerIndex = localStorage.getItem('superchat_server_index');\n    const savedCustomUrl = localStorage.getItem('superchat_custom_url');\n\n    this.renderServerList();\n    this.checkServerStatus();\n\n    // Select saved server after rendering\n    if (savedServerIndex !== null) {\n      const index = parseInt(savedServerIndex, 10);\n      if (index >= 0 && index < this.servers.length) {\n        this.selectServer(index);\n\n        // Restore custom URL if it was custom server\n        if (index === this.servers.length - 1 && savedCustomUrl) {\n          const serverUrlInput = document.getElementById('server-url') as HTMLInputElement;\n          if (serverUrlInput) {\n            serverUrlInput.value = savedCustomUrl;\n          }\n        }\n      }\n    }\n  }\n\n  private setupEventListeners() {\n    // Connect form\n    const form = document.getElementById('connect-form') as HTMLFormElement;\n    form.addEventListener('submit', (e) => {\n      e.preventDefault();\n      const url = (document.getElementById('server-url') as HTMLInputElement).value;\n      const nickname = (document.getElementById('nickname') as HTMLInputElement).value;\n      const throttle = parseInt((document.getElementById('throttle-speed') as HTMLSelectElement).value, 10);\n      this.throttleBytesPerSecond = throttle;\n\n      // Save nickname and server selection to localStorage\n      localStorage.setItem('superchat_nickname', nickname);\n      localStorage.setItem('superchat_server_index', this.selectedServerIndex.toString());\n\n      // Save custom URL if custom server is selected\n      if (this.selectedServerIndex === this.servers.length - 1) {\n        localStorage.setItem('superchat_custom_url', url);\n      }\n\n      this.connect(url, nickname);\n    });\n\n    // Mobile menu toggle\n    document.getElementById('mobile-menu-toggle')?.addEventListener('click', () => {\n      this.toggleMobileSidebar();\n    });\n\n    // Send message button\n    document.getElementById('send-button')?.addEventListener('click', () => {\n      this.sendMessage();\n    });\n\n    // Send message on Enter (Ctrl+Enter for newline)\n    document.getElementById('message-input')?.addEventListener('keydown', (e) => {\n      if (e.key === 'Enter' && !e.shiftKey && !e.ctrlKey) {\n        e.preventDefault();\n        this.sendMessage();\n      }\n      // Escape to cancel reply\n      if (e.key === 'Escape' && this.replyToMessageId !== null) {\n        this.cancelReply();\n      }\n    });\n\n    // Back button\n    document.addEventListener('click', (e) => {\n      const target = e.target as HTMLElement;\n      if (target.id === 'back-button') {\n        this.backToThreadList();\n      }\n    });\n\n    // Cancel reply button\n    document.getElementById('cancel-reply-button')?.addEventListener('click', () => {\n      this.cancelReply();\n    });\n  }\n\n  private cancelReply() {\n    this.replyToMessageId = null;\n    this.replyingToMessage = null;\n    this.updateComposeArea();\n    this.updateReplyContext();\n    this.showStatus('Reply cancelled', 'info');\n  }\n\n  private backToThreadList() {\n    // Unsubscribe from current thread\n    if (this.subscribedThreadId !== null) {\n      this.unsubscribeFromThread(this.subscribedThreadId);\n    }\n\n    this.currentThread = null;\n    this.currentView = ViewState.ThreadList;\n    this.renderMessages();\n    this.updateBackButton();\n    this.updateComposeArea();\n  }\n\n  private updateBackButton() {\n    const backButton = document.getElementById('back-button');\n    if (backButton) {\n      backButton.style.display = this.currentView === ViewState.ThreadDetail ? 'inline-block' : 'none';\n    }\n  }\n\n  private updateComposeArea() {\n    const composeArea = document.getElementById('compose-area');\n    const input = document.getElementById('message-input') as HTMLTextAreaElement;\n\n    if (!composeArea || !input) return;\n\n    // Chat channels (type 0) always show compose area\n    if (this.currentChannel && this.currentChannel.type === 0) {\n      composeArea.style.display = 'block';\n      input.placeholder = 'Type a message...';\n    } else if (this.currentView === ViewState.ThreadList) {\n      // Forum thread list: show compose area for creating new threads\n      composeArea.style.display = 'block';\n      input.placeholder = 'Start a new conversation...';\n    } else {\n      // Forum thread detail: only show when user clicked reply\n      const shouldShow = this.replyToMessageId !== null;\n      composeArea.style.display = shouldShow ? 'block' : 'none';\n\n      if (shouldShow) {\n        input.placeholder = 'Type your reply...';\n      } else {\n        input.value = '';\n      }\n    }\n  }\n\n  private updateReplyContext() {\n    const replyContext = document.getElementById('reply-context');\n    const replyToAuthor = document.getElementById('reply-to-author');\n    const replyToPreview = document.getElementById('reply-to-preview');\n\n    if (!replyContext || !replyToAuthor || !replyToPreview) return;\n\n    // Remove highlight from any previously highlighted message\n    document.querySelectorAll('.reply-target').forEach(el => {\n      el.classList.remove('reply-target');\n    });\n\n    if (this.replyingToMessage) {\n      // Show reply context\n      replyContext.style.display = 'block';\n      replyToAuthor.textContent = this.replyingToMessage.author_nickname;\n\n      // Show preview of message content (first 50 chars)\n      const preview = this.replyingToMessage.content.length > 50\n        ? this.replyingToMessage.content.substring(0, 50) + '...'\n        : this.replyingToMessage.content;\n      replyToPreview.textContent = `\"${preview}\"`;\n\n      // Highlight the message being replied to\n      const messageElement = document.querySelector(`[data-message-id=\"${this.replyingToMessage.message_id}\"]`);\n      if (messageElement) {\n        messageElement.classList.add('reply-target');\n      }\n    } else {\n      // Hide reply context\n      replyContext.style.display = 'none';\n      replyToAuthor.textContent = '';\n      replyToPreview.textContent = '';\n    }\n  }\n\n  private toggleMobileSidebar() {\n    const sidebar = document.getElementById('sidebar');\n    const toggle = document.getElementById('mobile-menu-toggle');\n    sidebar?.classList.toggle('mobile-open');\n    toggle?.classList.toggle('active');\n  }\n\n  private closeMobileSidebar() {\n    const sidebar = document.getElementById('sidebar');\n    const toggle = document.getElementById('mobile-menu-toggle');\n    sidebar?.classList.remove('mobile-open');\n    toggle?.classList.remove('active');\n  }\n\n  async connect(url: string, nickname: string) {\n    this.nickname = nickname;\n\n    try {\n      this.ws = new WebSocket(url);\n      this.ws.binaryType = 'arraybuffer';\n\n      this.ws.onopen = () => {\n        console.log('WebSocket connected');\n        this.sendSetNickname(nickname);\n        // Start ping interval (30 seconds)\n        this.pingInterval = window.setInterval(() => this.sendPing(), 30000);\n        // Start traffic stats update interval (1 second)\n        this.trafficUpdateInterval = window.setInterval(() => this.updateTrafficStats(), 1000);\n        // Start receive processing interval if throttling is enabled\n        if (this.throttleBytesPerSecond > 0) {\n          this.lastReceiveProcessTime = Date.now();\n          // Process receive buffer every 100ms\n          this.receiveProcessInterval = window.setInterval(() => this.processReceiveBuffer(), 100);\n        }\n      };\n\n      this.ws.onmessage = (event) => {\n        const data = new Uint8Array(event.data);\n        this.bytesReceived += data.length;\n        // Always process fragments immediately to assemble frames\n        this.handleFragment(data);\n      };\n\n      this.ws.onerror = (error) => {\n        console.error('WebSocket error:', error);\n        const errorMsg = error instanceof ErrorEvent && error.message ? error.message : error.toString();\n        this.showStatus(`Failed to connect to ${url}: ${errorMsg}`, 'error');\n      };\n\n      this.ws.onclose = (event) => {\n        console.log('WebSocket closed', event);\n        if (event.wasClean) {\n          this.showStatus('Disconnected from server', 'error');\n        } else {\n          this.showStatus(`Connection lost (code: ${event.code}). Server may be offline or unreachable.`, 'error');\n        }\n        if (this.pingInterval) {\n          clearInterval(this.pingInterval);\n          this.pingInterval = null;\n        }\n        if (this.trafficUpdateInterval) {\n          clearInterval(this.trafficUpdateInterval);\n          this.trafficUpdateInterval = null;\n        }\n        if (this.receiveProcessInterval) {\n          clearInterval(this.receiveProcessInterval);\n          this.receiveProcessInterval = null;\n        }\n      };\n    } catch (error) {\n      console.error('Failed to connect:', error);\n      this.showStatus('Failed to connect', 'error');\n    }\n  }\n\n  private sendFrame(messageType: number, payloadBytes: Uint8Array) {\n    if (!this.ws || this.ws.readyState !== WebSocket.OPEN) {\n      console.error('WebSocket not connected');\n      return;\n    }\n\n    // Encode frame header\n    const headerEncoder = new FrameHeaderEncoder();\n    const header = headerEncoder.encode({\n      length: 3 + payloadBytes.length, // version(1) + type(1) + flags(1) + payload\n      version: 1,\n      type: messageType,\n      flags: 0\n    });\n\n    // Combine header + payload\n    const frame = new Uint8Array(header.length + payloadBytes.length);\n    frame.set(header, 0);\n    frame.set(payloadBytes, header.length);\n\n    // Track bytes sent\n    this.bytesSent += frame.length;\n\n    // If throttling is enabled, queue the send\n    if (this.throttleBytesPerSecond > 0) {\n      this.pendingSends.push({ data: frame, timestamp: Date.now() });\n      this.processPendingSends();\n    } else {\n      this.ws.send(frame);\n    }\n  }\n\n  private processPendingSends() {\n    if (this.pendingSends.length === 0 || !this.ws || this.ws.readyState !== WebSocket.OPEN) {\n      return;\n    }\n\n    // Simple rate limiting: send one frame per interval based on throttle rate\n    // This is a rough approximation - real throttling would need more sophisticated flow control\n    const bytesPerInterval = Math.max(100, this.throttleBytesPerSecond / 10); // 100ms intervals\n\n    while (this.pendingSends.length > 0) {\n      const pending = this.pendingSends[0];\n\n      // Check if we can send based on throttle\n      if (pending.data.length <= bytesPerInterval) {\n        this.pendingSends.shift();\n        this.ws.send(pending.data);\n      } else {\n        // Wait for next interval\n        setTimeout(() => this.processPendingSends(), 100);\n        break;\n      }\n    }\n  }\n\n  private processReceiveBuffer() {\n    if (this.frameReceiveBuffer.length === 0) {\n      return;\n    }\n\n    const now = Date.now();\n    const elapsedMs = now - this.lastReceiveProcessTime;\n    const bytesAllowed = (this.throttleBytesPerSecond * elapsedMs) / 1000;\n\n    let bytesProcessed = 0;\n    const toProcess: Uint8Array[] = [];\n\n    // Process as many buffered frames as the throttle allows\n    while (this.frameReceiveBuffer.length > 0 && bytesProcessed < bytesAllowed) {\n      const buffered = this.frameReceiveBuffer[0];\n\n      // Check if we have enough \"bandwidth\" to process this frame\n      if (bytesProcessed + buffered.size <= bytesAllowed) {\n        this.frameReceiveBuffer.shift();\n        toProcess.push(buffered.frame);\n        bytesProcessed += buffered.size;\n        this.bytesReceivedThrottled += buffered.size;\n      } else {\n        // Not enough bandwidth for this frame yet\n        break;\n      }\n    }\n\n    // Update last process time\n    this.lastReceiveProcessTime = now;\n\n    // Process all the frames we're allowed to\n    for (const frame of toProcess) {\n      console.log(`Processing frame ${frame.length} bytes from buffer (${this.frameReceiveBuffer.length} remaining)`);\n      this.handleCompleteFrame(frame);\n    }\n  }\n\n  private handleFragment(fragment: Uint8Array) {\n    // Append fragment to buffer\n    const newBuffer = new Uint8Array(this.frameBuffer.length + fragment.length);\n    newBuffer.set(this.frameBuffer, 0);\n    newBuffer.set(fragment, this.frameBuffer.length);\n    this.frameBuffer = newBuffer;\n\n    // Try to extract complete frames from buffer\n    while (true) {\n      // Need at least 4 bytes to read frame length\n      if (this.expectedFrameLength === null && this.frameBuffer.length >= 4) {\n        // Read frame length (big-endian uint32)\n        const view = new DataView(this.frameBuffer.buffer, this.frameBuffer.byteOffset, 4);\n        this.expectedFrameLength = view.getUint32(0, false); // false = big-endian\n        console.log(`Expecting frame of ${this.expectedFrameLength} bytes (plus 4-byte length prefix)`);\n      }\n\n      // Check if we have a complete frame (length prefix + frame data)\n      if (this.expectedFrameLength !== null) {\n        const totalFrameSize = 4 + this.expectedFrameLength;\n        if (this.frameBuffer.length >= totalFrameSize) {\n          // Extract complete frame\n          const completeFrame = this.frameBuffer.slice(0, totalFrameSize);\n\n          // Remove frame from buffer\n          this.frameBuffer = this.frameBuffer.slice(totalFrameSize);\n          this.expectedFrameLength = null;\n\n          // If throttling is enabled, buffer the complete frame\n          if (this.throttleBytesPerSecond > 0) {\n            this.frameReceiveBuffer.push({\n              frame: completeFrame,\n              arrivedAt: Date.now(),\n              size: totalFrameSize\n            });\n            console.log(`Buffered frame ${totalFrameSize} bytes (buffer: ${this.frameReceiveBuffer.length} frames)`);\n          } else {\n            // No throttling - process immediately\n            this.handleCompleteFrame(completeFrame);\n          }\n\n          // Continue to check for more frames in buffer\n          continue;\n        }\n      }\n\n      // Not enough data yet, wait for more fragments\n      break;\n    }\n  }\n\n  private handleCompleteFrame(data: Uint8Array) {\n    this.handleMessage(data);\n  }\n\n  private handleMessage(data: Uint8Array) {\n    try {\n      // Debug: log raw frame data\n      console.log(`Received frame: ${data.length} bytes, first 20:`, Array.from(data.slice(0, 20)));\n\n      // Check minimum frame size\n      if (data.length < 7) {\n        console.error(`Frame too short: ${data.length} bytes (need at least 7 for header)`);\n        return;\n      }\n\n      // Decode frame header\n      const headerDecoder = new FrameHeaderDecoder(data);\n      const header = headerDecoder.decode();\n\n      console.log(`Decoded header: length=${header.length}, version=${header.version}, type=0x${header.type.toString(16)}, flags=${header.flags}`);\n\n      // Extract payload (skip length(4) + version(1) + type(1) + flags(1) = 7 bytes)\n      // Create a completely fresh copy with a new ArrayBuffer at offset 0\n      const payloadSlice = data.slice(7);\n      const payload = new Uint8Array(new ArrayBuffer(payloadSlice.length));\n      payload.set(payloadSlice);\n      console.log(`Payload: ${payload.length} bytes, byteOffset: ${payload.byteOffset}`);\n\n      switch (header.type) {\n        case MSG_SERVER_CONFIG:\n          this.handleServerConfig(payload);\n          break;\n        case MSG_NICKNAME_RESPONSE:\n          this.handleNicknameResponse(payload);\n          break;\n        case MSG_CHANNEL_LIST:\n          this.handleChannelList(payload);\n          break;\n        case MSG_JOIN_RESPONSE:\n          this.handleJoinResponse(payload);\n          break;\n        case MSG_MESSAGE_LIST:\n          this.handleMessageList(payload);\n          break;\n        case MSG_MESSAGE_POSTED:\n          this.handleMessagePosted(payload);\n          break;\n        case MSG_NEW_MESSAGE:\n          this.handleNewMessage(payload);\n          break;\n        case MSG_PONG:\n          console.log('Received PONG');\n          break;\n        case MSG_SUBSCRIBE_OK:\n          this.handleSubscribeOk(payload);\n          break;\n        case MSG_CHANNEL_PRESENCE:\n          // Channel presence notifications (users joining/leaving) - ignore for now\n          console.log('Received CHANNEL_PRESENCE notification');\n          break;\n        case MSG_ERROR:\n          this.handleError(payload);\n          break;\n        default:\n          console.warn(`Unhandled message type: 0x${header.type.toString(16)} (decimal ${header.type})`);\n      }\n    } catch (error) {\n      console.error('Error handling message:', error);\n      console.error('Frame data:', Array.from(data));\n    }\n  }\n\n  private sendSetNickname(nickname: string) {\n    const encoder = new SetNicknameEncoder();\n    const payload = encoder.encode({ nickname });\n    this.sendFrame(MSG_SET_NICKNAME, payload);\n  }\n\n  private handleServerConfig(payload: Uint8Array) {\n    try {\n      const decoder = new ServerConfigDecoder(payload);\n      const config = decoder.decode();\n      console.log('Received SERVER_CONFIG:', config);\n      // Store config if needed in the future\n    } catch (error) {\n      console.error('Error decoding SERVER_CONFIG:', error);\n    }\n  }\n\n  private handleError(payload: Uint8Array) {\n    try {\n      const decoder = new Error_Decoder(payload);\n      const error = decoder.decode();\n      console.error(`Server error ${error.error_code}: ${error.message}`);\n      this.showStatus(`Server error: ${error.message}`, 'error');\n    } catch (error) {\n      console.error('Error decoding ERROR message:', error);\n    }\n  }\n\n  private handleNicknameResponse(payload: Uint8Array) {\n    const decoder = new NicknameResponseDecoder(payload);\n    const response = decoder.decode();\n\n    if (response.success === 1) {\n      console.log('Nickname set successfully:', response.message);\n      this.showStatus(response.message, 'success');\n\n      // Server echoes back the actual nickname (with ~ if anonymous)\n      // We can extract it from the success message or just check our original nickname\n      // If server accepted it without ~, we're registered\n      this.isRegistered = !this.nickname.startsWith('~');\n\n      // Hide connect panel and show app\n      document.getElementById('connect-panel')?.classList.add('hidden');\n      document.getElementById('app')!.style.display = 'flex';\n\n      // Request channel list\n      this.sendListChannels();\n    } else {\n      this.showStatus(response.message, 'error');\n    }\n  }\n\n  private sendListChannels() {\n    const encoder = new ListChannelsEncoder();\n    const payload = encoder.encode({ from_channel_id: 0n, limit: 100 });\n    this.sendFrame(MSG_LIST_CHANNELS, payload);\n  }\n\n  private handleChannelList(payload: Uint8Array) {\n    try {\n      const decoder = new ChannelListDecoder(payload);\n      const channelList = decoder.decode();\n\n      console.log(`Received ${channelList.channel_count} channels`);\n\n      // Store channels\n      this.channels.clear();\n      for (const channel of channelList.channels) {\n        this.channels.set(channel.channel_id, channel);\n      }\n\n      // Update UI\n      this.renderChannels();\n    } catch (error) {\n      console.error('Error decoding CHANNEL_LIST:', error);\n      throw error;\n    }\n  }\n\n  private renderChannels() {\n    const list = document.getElementById('channel-list')!;\n    list.innerHTML = '';\n\n    for (const channel of this.channels.values()) {\n      const item = document.createElement('div');\n      item.className = 'channel-item';\n      if (this.currentChannel?.channel_id === channel.channel_id) {\n        item.classList.add('active');\n      }\n\n      const prefix = channel.type === 0 ? '>' : '#';\n      item.innerHTML = `\n        <div class=\"channel-name\">${prefix} ${channel.name}</div>\n        <div class=\"channel-info\">${channel.user_count} online \u2022 ${channel.type === 0 ? 'Chat' : 'Forum'}</div>\n      `;\n\n      item.addEventListener('click', () => {\n        this.joinChannel(channel);\n        this.closeMobileSidebar();\n      });\n      list.appendChild(item);\n    }\n  }\n\n  private joinChannel(channel: Channel) {\n    const encoder = new JoinChannelEncoder();\n    const payload = encoder.encode({\n      channel_id: channel.channel_id,\n      subchannel_id: { present: 0 }\n    });\n    this.sendFrame(MSG_JOIN_CHANNEL, payload);\n  }\n\n  private handleJoinResponse(payload: Uint8Array) {\n    const decoder = new JoinResponseDecoder(payload);\n    const response = decoder.decode();\n\n    if (response.success === 1) {\n      const channel = this.channels.get(response.channel_id);\n      if (channel) {\n        this.currentChannel = channel;\n        console.log('Joined channel:', channel.name);\n\n        // Reset view state when switching channels\n        if (this.subscribedThreadId !== null) {\n          this.unsubscribeFromThread(this.subscribedThreadId);\n        }\n        this.currentView = ViewState.ThreadList;\n        this.currentThread = null;\n        this.replyToMessageId = null;\n        this.replyingToMessage = null;\n        this.threads = [];\n        this.threadReplies.clear();\n\n        // Update UI\n        this.updateChannelTitle();\n        this.renderChannels();\n        this.updateBackButton();\n        this.updateComposeArea();\n\n        // Subscribe to channel for real-time updates\n        this.subscribeToChannel(channel.channel_id);\n\n        // Request messages\n        this.sendListMessages(channel.channel_id);\n      }\n    } else {\n      this.showStatus(response.message, 'error');\n    }\n  }\n\n  private subscribeToChannel(channelId: bigint) {\n    // Unsubscribe from previous channel if any\n    if (this.subscribedChannelId !== null && this.subscribedChannelId !== channelId) {\n      this.unsubscribeFromChannel(this.subscribedChannelId);\n    }\n\n    const encoder = new SubscribeChannelEncoder();\n    const payload = encoder.encode({\n      channel_id: channelId,\n      subchannel_id: { present: 0 }\n    });\n    this.sendFrame(MSG_SUBSCRIBE_CHANNEL, payload);\n    console.log(`Subscribing to channel ${channelId}...`);\n  }\n\n  private unsubscribeFromChannel(channelId: bigint) {\n    const encoder = new UnsubscribeChannelEncoder();\n    const payload = encoder.encode({\n      channel_id: channelId,\n      subchannel_id: { present: 0 }\n    });\n    this.sendFrame(MSG_UNSUBSCRIBE_CHANNEL, payload);\n    console.log(`Unsubscribed from channel ${channelId}`);\n    this.subscribedChannelId = null;\n  }\n\n  private subscribeToThread(threadId: bigint) {\n    // Unsubscribe from previous thread if any\n    if (this.subscribedThreadId !== null && this.subscribedThreadId !== threadId) {\n      this.unsubscribeFromThread(this.subscribedThreadId);\n    }\n\n    const encoder = new SubscribeThreadEncoder();\n    const payload = encoder.encode({ thread_id: threadId });\n    this.sendFrame(MSG_SUBSCRIBE_THREAD, payload);\n    console.log(`Subscribing to thread ${threadId}...`);\n  }\n\n  private unsubscribeFromThread(threadId: bigint) {\n    const encoder = new UnsubscribeThreadEncoder();\n    const payload = encoder.encode({ thread_id: threadId });\n    this.sendFrame(MSG_UNSUBSCRIBE_THREAD, payload);\n    console.log(`Unsubscribed from thread ${threadId}`);\n    this.subscribedThreadId = null;\n  }\n\n  private handleSubscribeOk(payload: Uint8Array) {\n    try {\n      const decoder = new SubscribeOkDecoder(payload);\n      const response = decoder.decode();\n\n      if (response.type === MSG_SUBSCRIBE_CHANNEL) {\n        this.subscribedChannelId = response.id;\n        console.log(`Successfully subscribed to channel ${response.id}`);\n        this.updateChannelTitle(); // Update title to show connection indicator\n      } else if (response.type === MSG_SUBSCRIBE_THREAD) {\n        this.subscribedThreadId = response.id;\n        console.log(`Successfully subscribed to thread ${response.id}`);\n      }\n    } catch (error) {\n      console.error('Error decoding SUBSCRIBE_OK:', error);\n    }\n  }\n\n  private sendListMessages(channelId: bigint) {\n    const encoder = new ListMessagesEncoder();\n    const payload = encoder.encode({\n      channel_id: channelId,\n      subchannel_id: { present: 0 },\n      limit: 50,\n      before_id: { present: 0 },\n      parent_id: { present: 0 },\n      after_id: { present: 0 }\n    });\n    this.sendFrame(MSG_LIST_MESSAGES, payload);\n  }\n\n  private handleMessageList(payload: Uint8Array) {\n    const decoder = new MessageListDecoder(payload);\n    const messageList = decoder.decode();\n\n    console.log(`Received ${messageList.message_count} messages for channel ${messageList.channel_id}`);\n\n    // Check if this is a response for thread replies (parent_id was set in request)\n    const isThreadReplies = messageList.parent_id.present === 1;\n\n    if (isThreadReplies) {\n      // These are replies to a specific thread\n      const threadId = messageList.parent_id.value!;\n      this.threadReplies.set(threadId, messageList.messages);\n      console.log(`Loaded ${messageList.messages.length} replies for thread ${threadId}`);\n    } else {\n      // These are root-level messages (threads)\n      // Filter to only include messages with no parent\n      this.threads = messageList.messages.filter(msg => msg.parent_id.present === 0);\n      console.log(`Loaded ${this.threads.length} threads`);\n    }\n\n    // Update UI if this is the current channel\n    if (this.currentChannel?.channel_id === messageList.channel_id) {\n      this.renderMessages();\n\n      // Auto-scroll to bottom when loading thread replies in chat channels (type 0)\n      console.log(`handleMessageList: isThreadReplies=${isThreadReplies}, currentView=${this.currentView}, channel.type=${this.currentChannel.type}`);\n      if (isThreadReplies && this.currentView === ViewState.ThreadDetail && this.currentChannel.type === 0) {\n        console.log('Auto-scrolling after loading thread replies');\n        setTimeout(() => {\n          const container = document.getElementById('messages');\n          if (container) {\n            console.log(`Scrolling: scrollTop=${container.scrollTop} -> scrollHeight=${container.scrollHeight}`);\n            container.scrollTop = container.scrollHeight;\n          }\n        }, 50); // Small delay to ensure render is complete\n      }\n    }\n  }\n\n  private renderMessages() {\n    // Chat channels (type 0) show a flat list of all messages\n    if (this.currentChannel && this.currentChannel.type === 0) {\n      this.renderChatMessages();\n    } else if (this.currentView === ViewState.ThreadList) {\n      this.renderThreadList();\n    } else {\n      this.renderThreadDetail();\n    }\n  }\n\n  private renderChatMessages() {\n    const container = document.getElementById('messages')!;\n\n    if (!this.currentChannel) {\n      container.innerHTML = '<div class=\"empty-state\"><h3>Select a channel</h3></div>';\n      return;\n    }\n\n    if (this.threads.length === 0) {\n      container.innerHTML = '<div class=\"empty-state\"><h3>No messages yet</h3><p>Start chatting!</p></div>';\n      return;\n    }\n\n    container.innerHTML = '';\n\n    let lastDate: string | null = null;\n\n    // Render all messages in chronological order\n    for (const message of this.threads) {\n      const date = new Date(Number(message.created_at));\n      const dateStr = date.toLocaleDateString();\n      const timeStr = date.toLocaleTimeString();\n\n      // Show date separator if date changed\n      if (lastDate !== dateStr) {\n        const dateSeparator = document.createElement('div');\n        dateSeparator.className = 'date-separator';\n        dateSeparator.textContent = dateStr;\n        container.appendChild(dateSeparator);\n        lastDate = dateStr;\n      }\n\n      const div = document.createElement('div');\n      div.className = 'chat-message';\n      div.setAttribute('data-message-id', message.message_id.toString());\n\n      div.innerHTML = `\n        <span class=\"chat-time\">${timeStr}</span>\n        <span class=\"chat-author\">${this.escapeHtml(message.author_nickname)}</span>\n        <span class=\"chat-content\">${this.escapeHtml(message.content)}</span>\n      `;\n\n      container.appendChild(div);\n    }\n\n    // Auto-scroll to bottom for chat channels\n    console.log(`renderChatMessages: scrolling to bottom, scrollHeight=${container.scrollHeight}`);\n    container.scrollTop = container.scrollHeight;\n  }\n\n  private renderThreadList() {\n    const container = document.getElementById('messages')!;\n\n    if (!this.currentChannel) {\n      container.innerHTML = '<div class=\"empty-state\"><h3>Select a channel</h3></div>';\n      return;\n    }\n\n    if (this.threads.length === 0) {\n      container.innerHTML = '<div class=\"empty-state\"><h3>No threads yet</h3><p>Start a conversation!</p></div>';\n      return;\n    }\n\n    container.innerHTML = '';\n\n    for (const thread of this.threads) {\n      const div = document.createElement('div');\n      div.className = 'thread-item';\n\n      const date = new Date(Number(thread.created_at));\n      const timeStr = date.toLocaleTimeString();\n\n      // Create preview (first 80 chars of content)\n      const preview = thread.content.length > 80\n        ? thread.content.substring(0, 80) + '...'\n        : thread.content;\n\n      // Reply count badge\n      const replyBadge = thread.reply_count > 0\n        ? `<span class=\"reply-count-badge\">${thread.reply_count} ${thread.reply_count === 1 ? 'reply' : 'replies'}</span>`\n        : '';\n\n      div.innerHTML = `\n        <div class=\"thread-header\">\n          <span class=\"thread-author\">${this.escapeHtml(thread.author_nickname)}</span>\n          <span class=\"thread-time\">${timeStr}</span>\n        </div>\n        <div class=\"thread-preview\">${this.escapeHtml(preview)}</div>\n        <div class=\"thread-footer\">\n          ${replyBadge}\n        </div>\n      `;\n\n      // Click to open thread\n      div.addEventListener('click', () => {\n        this.openThread(thread);\n      });\n\n      container.appendChild(div);\n    }\n\n    // Scroll to top when showing thread list\n    container.scrollTop = 0;\n  }\n\n  private renderThreadDetail() {\n    const container = document.getElementById('messages')!;\n\n    if (!this.currentThread) {\n      container.innerHTML = '<div class=\"empty-state\"><h3>No thread selected</h3></div>';\n      return;\n    }\n\n    container.innerHTML = '';\n\n    // Show root message\n    this.renderMessage(container, this.currentThread, 0, true);\n\n    // Build tree and render replies\n    const replies = this.threadReplies.get(this.currentThread.message_id) || [];\n    const messageTree = this.buildMessageTree(replies, this.currentThread.message_id);\n    this.renderMessageTree(container, messageTree, 1);\n\n    // Add click handlers for reply buttons\n    container.querySelectorAll('.reply-button').forEach(button => {\n      button.addEventListener('click', (e) => {\n        e.stopPropagation();\n        const messageId = BigInt((e.target as HTMLElement).getAttribute('data-message-id')!);\n        this.replyToMessage(messageId);\n      });\n    });\n\n    // Scroll to bottom only for chat channels (type 0)\n    console.log(`renderThreadDetail: channel.type=${this.currentChannel?.type}`);\n    if (this.currentChannel && this.currentChannel.type === 0) {\n      console.log(`Auto-scrolling in renderThreadDetail: scrollHeight=${container.scrollHeight}`);\n      container.scrollTop = container.scrollHeight;\n    }\n  }\n\n  private buildMessageTree(messages: Message[], rootId: bigint): Message[] {\n    // Build a map of parent_id -> children\n    const childrenMap = new Map<bigint, Message[]>();\n\n    for (const msg of messages) {\n      if (msg.parent_id.present === 1) {\n        const parentId = msg.parent_id.value!;\n        if (!childrenMap.has(parentId)) {\n          childrenMap.set(parentId, []);\n        }\n        childrenMap.get(parentId)!.push(msg);\n      }\n    }\n\n    // Get direct children of the root\n    return childrenMap.get(rootId) || [];\n  }\n\n  private renderMessageTree(container: HTMLElement, messages: Message[], depth: number) {\n    for (const msg of messages) {\n      this.renderMessage(container, msg, depth, false);\n\n      // Recursively render children\n      const replies = this.threadReplies.get(this.currentThread!.message_id) || [];\n      const children = this.buildMessageTree(replies, msg.message_id);\n      if (children.length > 0) {\n        this.renderMessageTree(container, children, depth + 1);\n      }\n    }\n  }\n\n  private renderMessage(container: HTMLElement, message: Message, depth: number, isRoot: boolean) {\n    const div = document.createElement('div');\n    div.className = isRoot ? 'message thread-root' : 'message thread-reply';\n    div.setAttribute('data-message-id', message.message_id.toString());\n\n    // Add indentation based on depth (but not for root)\n    if (!isRoot && depth > 0) {\n      div.style.marginLeft = `${depth * 2}rem`;\n    }\n\n    const date = new Date(Number(message.created_at));\n    const timeStr = date.toLocaleTimeString();\n\n    div.innerHTML = `\n      <div class=\"message-header\">\n        <span class=\"message-author\">${this.escapeHtml(message.author_nickname)}</span>\n        <span class=\"message-time\">${timeStr}</span>\n      </div>\n      <div class=\"message-content\">${this.escapeHtml(message.content)}</div>\n      <div class=\"message-actions\">\n        <button class=\"reply-button\" data-message-id=\"${message.message_id}\">Reply</button>\n      </div>\n    `;\n\n    container.appendChild(div);\n  }\n\n  private openThread(thread: Message) {\n    this.currentThread = thread;\n    this.currentView = ViewState.ThreadDetail;\n    this.updateBackButton();\n    this.updateComposeArea();\n\n    // Subscribe to thread for real-time reply updates\n    this.subscribeToThread(thread.message_id);\n\n    // Load replies for this thread\n    this.loadThreadReplies(thread.message_id);\n  }\n\n  private loadThreadReplies(threadId: bigint) {\n    const encoder = new ListMessagesEncoder();\n    const payload = encoder.encode({\n      channel_id: this.currentChannel!.channel_id,\n      subchannel_id: { present: 0 },\n      limit: 100,\n      before_id: { present: 0 },\n      parent_id: { present: 1, value: threadId },\n      after_id: { present: 0 }\n    });\n    this.sendFrame(MSG_LIST_MESSAGES, payload);\n  }\n\n  private replyToMessage(messageId: bigint) {\n    this.replyToMessageId = messageId;\n\n    // Find the message being replied to\n    if (this.currentThread && this.currentThread.message_id === messageId) {\n      this.replyingToMessage = this.currentThread;\n    } else {\n      const replies = this.threadReplies.get(this.currentThread!.message_id) || [];\n      this.replyingToMessage = replies.find(m => m.message_id === messageId) || null;\n    }\n\n    this.updateComposeArea();\n    this.updateReplyContext();\n\n    // Focus the input\n    const input = document.getElementById('message-input') as HTMLTextAreaElement;\n    input.focus();\n\n    this.showStatus('Reply mode active - press Escape to cancel', 'info');\n  }\n\n  private handleNewMessage(payload: Uint8Array) {\n    const decoder = new NewMessageDecoder(payload);\n    const newMsg = decoder.decode();\n\n    console.log('Received new message:', newMsg);\n\n    const message: Message = {\n      message_id: newMsg.message_id,\n      channel_id: newMsg.channel_id,\n      subchannel_id: newMsg.subchannel_id,\n      parent_id: newMsg.parent_id,\n      author_user_id: newMsg.author_user_id,\n      author_nickname: newMsg.author_nickname,\n      content: newMsg.content,\n      created_at: newMsg.created_at,\n      edited_at: newMsg.edited_at,\n      reply_count: newMsg.reply_count\n    };\n\n    // Check if this is our own message by comparing nicknames\n    const isOurMessage = this.isOwnMessage(message.author_nickname);\n\n    // Determine if this is a root message (thread) or a reply\n    if (message.parent_id.present === 0) {\n      // Root message - add to threads list\n      this.threads.push(message);\n      console.log('Added new thread to list');\n    } else {\n      // Reply - we need to find the ROOT of the thread to add it there\n      // The message's parent_id might be the root OR another reply\n      const parentId = message.parent_id.value!;\n\n      // Find which thread this belongs to (could be root or need to traverse up)\n      let rootThreadId = parentId;\n\n      // Check if parentId is a root thread\n      const isRootThread = this.threads.some(t => t.message_id === parentId);\n      if (!isRootThread) {\n        // Parent is a reply, find its root by checking currentThread\n        if (this.currentThread) {\n          rootThreadId = this.currentThread.message_id;\n        }\n      }\n\n      // Add to the root thread's replies\n      const replies = this.threadReplies.get(rootThreadId) || [];\n      replies.push(message);\n      this.threadReplies.set(rootThreadId, replies);\n      console.log(`Added reply to thread ${rootThreadId}`);\n\n      // Update reply count in threads list (only increment for the root thread)\n      const thread = this.threads.find(t => t.message_id === rootThreadId);\n      if (thread) {\n        thread.reply_count++;\n      }\n    }\n\n    // Update UI if this is the current channel\n    if (this.currentChannel?.channel_id === newMsg.channel_id) {\n      this.renderMessages();\n\n      // Auto-scroll to bottom for chat channels (type 0) or when viewing thread detail\n      const shouldScroll = this.currentChannel.type === 0 || this.currentView === ViewState.ThreadDetail;\n      if (shouldScroll) {\n        setTimeout(() => {\n          const container = document.getElementById('messages');\n          if (container) {\n            container.scrollTop = container.scrollHeight;\n          }\n        }, 50); // Small delay to ensure render is complete\n      }\n    }\n  }\n\n  private sendMessage() {\n    const input = document.getElementById('message-input') as HTMLTextAreaElement;\n    const content = input.value.trim();\n\n    if (!content || !this.currentChannel) {\n      return;\n    }\n\n    const encoder = new PostMessageEncoder();\n    const payload = encoder.encode({\n      channel_id: this.currentChannel.channel_id,\n      subchannel_id: { present: 0 },\n      parent_id: this.replyToMessageId !== null\n        ? { present: 1, value: this.replyToMessageId }\n        : { present: 0 },\n      content\n    });\n    this.sendFrame(MSG_POST_MESSAGE, payload);\n\n    // Clear input and reply context\n    input.value = '';\n    this.replyToMessageId = null;\n    this.replyingToMessage = null;\n    this.updateComposeArea();\n    this.updateReplyContext();\n  }\n\n  private handleMessagePosted(payload: Uint8Array) {\n    const decoder = new MessagePostedDecoder(payload);\n    const response = decoder.decode();\n\n    if (response.success === 1) {\n      console.log('Message posted successfully:', response.message_id);\n    } else {\n      this.showStatus(response.message, 'error');\n    }\n  }\n\n  private sendPing() {\n    const encoder = new PingEncoder();\n    const payload = encoder.encode({ timestamp: BigInt(Date.now()) });\n    this.sendFrame(MSG_PING, payload);\n  }\n\n  private showStatus(message: string, type: 'success' | 'error' | 'info' = 'info') {\n    // Create status element if it doesn't exist\n    let status = document.getElementById('status-bar');\n    if (!status) {\n      status = document.createElement('div');\n      status.id = 'status-bar';\n      status.className = 'status';\n      document.body.prepend(status);\n    }\n\n    status.textContent = message;\n    status.className = `status ${type}`;\n\n    // Auto-hide after 3 seconds\n    setTimeout(() => {\n      status?.remove();\n    }, 3000);\n  }\n\n  private escapeHtml(text: string): string {\n    const div = document.createElement('div');\n    div.textContent = text;\n    return div.innerHTML;\n  }\n\n  private isOwnMessage(authorNickname: string): boolean {\n    // If we're registered, check for exact match\n    if (this.isRegistered) {\n      return authorNickname === this.nickname;\n    }\n    // If we're anonymous, check for ~nickname\n    return authorNickname === `~${this.nickname}`;\n  }\n\n  private formatBytes(bytes: number): string {\n    const unit = 1024;\n    if (bytes < unit) {\n      return `${bytes}B`;\n    }\n    let div = unit;\n    let exp = 0;\n    for (let n = Math.floor(bytes / unit); n >= unit; n = Math.floor(n / unit)) {\n      div *= unit;\n      exp++;\n    }\n    const units = 'KMGTPE';\n    return `${(bytes / div).toFixed(1)}${units[exp]}B`;\n  }\n\n  private renderServerList() {\n    const serverList = document.getElementById('server-list');\n    if (!serverList) return;\n\n    serverList.innerHTML = '';\n\n    this.servers.forEach((server, index) => {\n      const url = server.isSecure ? server.wssUrl : server.wsUrl;\n      const isCustom = server.name === 'Custom Server';\n      const isSelected = this.selectedServerIndex === index;\n\n      const serverItem = document.createElement('div');\n      serverItem.className = `server-item ${isSelected ? 'selected' : ''}`;\n      serverItem.onclick = () => this.selectServer(index);\n\n      const serverInfo = document.createElement('div');\n      serverInfo.className = 'server-info';\n\n      const serverName = document.createElement('div');\n      serverName.className = 'server-name';\n      serverName.textContent = server.name;\n\n      serverInfo.appendChild(serverName);\n\n      // Only show URL and badge for non-custom servers\n      if (!isCustom) {\n        const statusDot = document.createElement('div');\n        statusDot.className = `server-status ${server.status}`;\n        serverItem.appendChild(statusDot);\n\n        const serverUrl = document.createElement('div');\n        serverUrl.className = 'server-url';\n        serverUrl.textContent = url;\n        serverInfo.appendChild(serverUrl);\n\n        serverItem.appendChild(serverInfo);\n\n        const badge = document.createElement('span');\n        badge.className = `server-badge ${server.isSecure ? 'secure' : 'insecure'}`;\n        badge.textContent = server.isSecure ? 'WSS' : 'WS';\n        serverItem.appendChild(badge);\n      } else {\n        const serverDescription = document.createElement('div');\n        serverDescription.className = 'server-url';\n        serverDescription.textContent = 'Enter your own server URL';\n        serverInfo.appendChild(serverDescription);\n\n        serverItem.appendChild(serverInfo);\n      }\n\n      serverList.appendChild(serverItem);\n    });\n\n    // Select first server by default if none selected\n    if (this.selectedServerIndex === -1 && this.servers.length > 0) {\n      this.selectServer(0);\n    }\n  }\n\n  private selectServer(index: number) {\n    const server = this.servers[index];\n    const isCustom = server.name === 'Custom Server';\n\n    this.selectedServerIndex = index;\n    this.selectedServerUrl = server.isSecure ? server.wssUrl : server.wsUrl;\n\n    const serverUrlInput = document.getElementById('server-url') as HTMLInputElement;\n    const serverUrlGroup = serverUrlInput?.closest('.form-group') as HTMLElement;\n\n    if (serverUrlInput) {\n      serverUrlInput.value = this.selectedServerUrl;\n      serverUrlInput.readOnly = !isCustom;\n      serverUrlInput.placeholder = isCustom ? 'Enter server URL (ws:// or wss://)' : '';\n\n      // Show/hide the server URL field\n      if (serverUrlGroup) {\n        serverUrlGroup.style.display = isCustom ? 'block' : 'none';\n      }\n\n      // Focus the input if custom server is selected\n      if (isCustom) {\n        serverUrlInput.focus();\n      }\n    }\n\n    this.renderServerList();\n  }\n\n  private async checkServerStatus() {\n    for (let i = 0; i < this.servers.length; i++) {\n      const server = this.servers[i];\n\n      // Try secure first, then insecure\n      const urlsToTry = [server.wssUrl, server.wsUrl];\n      let isOnline = false;\n      let secureWorks = false;\n\n      for (const url of urlsToTry) {\n        try {\n          const online = await this.probeServer(url);\n          if (online) {\n            isOnline = true;\n            secureWorks = url === server.wssUrl;\n            break;\n          }\n        } catch (error) {\n          // Try next URL\n        }\n      }\n\n      this.servers[i].status = isOnline ? 'online' : 'offline';\n      this.servers[i].isSecure = secureWorks;\n      this.renderServerList();\n    }\n  }\n\n  private probeServer(url: string): Promise<boolean> {\n    return new Promise((resolve) => {\n      const ws = new WebSocket(url);\n      const timeout = setTimeout(() => {\n        ws.close();\n        resolve(false);\n      }, 3000);\n\n      ws.onopen = () => {\n        clearTimeout(timeout);\n        ws.close();\n        resolve(true);\n      };\n\n      ws.onerror = () => {\n        clearTimeout(timeout);\n        resolve(false);\n      };\n    });\n  }\n\n  private updateChannelTitle() {\n    if (!this.currentChannel) return;\n\n    const titleEl = document.getElementById('channel-title');\n    if (!titleEl) {\n      console.warn('channel-title element not found');\n      return;\n    }\n\n    const prefix = this.currentChannel.type === 0 ? '>' : '#';\n\n    // Create title with connection indicator using flexbox for alignment\n    titleEl.innerHTML = '';\n    titleEl.style.display = 'flex';\n    titleEl.style.alignItems = 'center';\n    titleEl.style.gap = '8px';\n\n    // Show green indicator when we have an active channel\n    const indicator = document.createElement('span');\n    indicator.style.cssText = 'display: block; width: 8px; height: 8px; border-radius: 50%; background: #10b981; box-shadow: 0 0 6px rgba(16, 185, 129, 0.6); flex-shrink: 0;';\n    titleEl.appendChild(indicator);\n\n    const text = document.createTextNode(`${prefix} ${this.currentChannel.name}`);\n    titleEl.appendChild(text);\n  }\n\n  private formatBandwidth(bytesPerSec: number): string {\n    // Convert bytes/sec to bits/sec (multiply by 8)\n    const bitsPerSec = bytesPerSec * 8;\n\n    // Common modem speeds in bits/sec\n    if (bitsPerSec <= 14400) return '14.4k';\n    if (bitsPerSec <= 28800) return '28.8k';\n    if (bitsPerSec <= 33600) return '33.6k';\n    if (bitsPerSec <= 56000) return '56k';\n    if (bitsPerSec <= 128000) return '128k';\n    if (bitsPerSec <= 256000) return '256k';\n    if (bitsPerSec <= 512000) return '512k';\n    if (bitsPerSec <= 1024000) return '1Mbps';\n    if (bitsPerSec <= 10240000) return `${(bitsPerSec / 1000000).toFixed(1)}Mbps`;\n    return `${(bitsPerSec / 1000000).toFixed(1)}Mbps`;\n  }\n\n  private updateTrafficStats() {\n    // Update the traffic display in the header\n    const trafficElement = document.getElementById('traffic-stats');\n    if (trafficElement && this.ws && this.ws.readyState === WebSocket.OPEN) {\n      const sent = this.formatBytes(this.bytesSent);\n\n      // Show throttled receive count if throttling is enabled, otherwise show actual\n      const recvBytes = this.throttleBytesPerSecond > 0 ? this.bytesReceivedThrottled : this.bytesReceived;\n      const recv = this.formatBytes(recvBytes);\n\n      let html = `<span style=\"color: #9ca3af;\">\u2191${sent} \u2193${recv}</span>`;\n\n      // Add throttle indicator and buffer status if enabled\n      if (this.throttleBytesPerSecond > 0) {\n        const speed = this.formatBandwidth(this.throttleBytesPerSecond);\n        html += ` <span style=\"color: #9ca3af;\">\u23F1 ${speed}</span>`;\n\n        // Show buffered data if any\n        if (this.frameReceiveBuffer.length > 0) {\n          const bufferedBytes = this.frameReceiveBuffer.reduce((sum, item) => sum + item.size, 0);\n          const buffered = this.formatBytes(bufferedBytes);\n          html += ` <span style=\"color: #f59e0b;\">(${buffered} buffered)</span>`;\n        }\n      }\n\n      trafficElement.innerHTML = html;\n    }\n  }\n}\n\n// Initialize client when DOM is ready\nif (document.readyState === 'loading') {\n  document.addEventListener('DOMContentLoaded', () => new SuperChatClient());\n} else {\n  new SuperChatClient();\n}\n"],
  "mappings": "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",
  "names": ["i", "i"]
}
