// ABOUTME: Batched compilation for Go test suites
// ABOUTME: Compiles all test suites at once for fast execution

package test

import (
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"strings"

	"github.com/aeolun/json5"
	"github.com/anthropics/binschema/codegen"
)

// CompileAndTestBatch compiles all test suites together and runs them
func CompileAndTestBatch(suites []*TestSuite) (map[string][]TestResult, error) {
	// Create temporary directory
	tmpDir, err := os.MkdirTemp("", "binschema-batch-*")
	if err != nil {
		return nil, fmt.Errorf("failed to create temp dir: %w", err)
	}
	defer os.RemoveAll(tmpDir)

	// Generate code for all suites - write each to its own file in main package
	for i, suite := range suites {
		code, err := codegen.GenerateGo(suite.Schema, suite.TestType)
		if err != nil {
			return nil, fmt.Errorf("failed to generate code for %s: %w", suite.Name, err)
		}

		// Prefix type names to avoid conflicts
		prefix := strings.ReplaceAll(suite.Name, "-", "_")
		prefixedCode := prefixTypeNames(code, suite.TestType, prefix)

		// Write to separate file (Go allows multiple files in same package/directory)
		filename := fmt.Sprintf("gen_%d.go", i)
		codeFile := filepath.Join(tmpDir, filename)
		if err := os.WriteFile(codeFile, []byte(prefixedCode), 0644); err != nil {
			return nil, fmt.Errorf("failed to write generated code: %w", err)
		}
	}

	// Generate type name prefixes for the test harness
	var typeNamePrefixes []string
	for _, suite := range suites {
		prefix := strings.ReplaceAll(suite.Name, "-", "_")
		typeNamePrefixes = append(typeNamePrefixes, prefix)
	}

	// Generate unified test harness
	testHarness := generateBatchedTestHarness(suites, typeNamePrefixes)
	harnessFile := filepath.Join(tmpDir, "main.go")
	if err := os.WriteFile(harnessFile, []byte(testHarness), 0644); err != nil {
		return nil, fmt.Errorf("failed to write test harness: %w", err)
	}

	// Initialize go.mod
	cmd := exec.Command("go", "mod", "init", "testmodule")
	cmd.Dir = tmpDir
	if err := cmd.Run(); err != nil {
		return nil, fmt.Errorf("failed to init go module: %w", err)
	}

	// Add dependency on binschema runtime
	runtimePath, err := filepath.Abs(".")
	if err != nil {
		return nil, fmt.Errorf("failed to get abs path: %w", err)
	}
	runtimePath = filepath.Dir(runtimePath) // go up to binschema root

	goModPath := filepath.Join(tmpDir, "go.mod")
	goModContent, err := os.ReadFile(goModPath)
	if err != nil {
		return nil, fmt.Errorf("failed to read go.mod: %w", err)
	}

	goModContent = append(goModContent, []byte(fmt.Sprintf("\nreplace github.com/anthropics/binschema => %s\n", runtimePath))...)
	if err := os.WriteFile(goModPath, goModContent, 0644); err != nil {
		return nil, fmt.Errorf("failed to update go.mod: %w", err)
	}

	// Run go get to fetch dependencies
	cmd = exec.Command("go", "get", "github.com/anthropics/binschema/runtime", "github.com/aeolun/json5")
	cmd.Dir = tmpDir
	if output, err := cmd.CombinedOutput(); err != nil {
		return nil, fmt.Errorf("failed to get dependencies: %w\nOutput: %s", err, output)
	}

	// Run the test harness (only one compilation!)
	cmd = exec.Command("go", "run", ".")
	cmd.Dir = tmpDir
	output, err := cmd.CombinedOutput()
	if err != nil {
		return nil, fmt.Errorf("failed to run test harness: %w\nOutput: %s", err, output)
	}

	// Parse results - array of arrays, one per suite
	var allResults [][]TestResult
	if err := json5.Unmarshal(output, &allResults); err != nil {
		return nil, fmt.Errorf("failed to parse test results: %w\nOutput: %s", err, output)
	}

	// Map results back to suite names
	resultMap := make(map[string][]TestResult)
	for i, suite := range suites {
		if i < len(allResults) {
			resultMap[suite.Name] = allResults[i]
		}
	}

	return resultMap, nil
}

// prefixTypeNames adds a prefix to type names and helper functions to avoid conflicts
func prefixTypeNames(code string, typeName string, prefix string) string {
	// Change package to main and keep imports
	code = strings.Replace(code, "package main", "package main", 1)

	// Prefix the main type everywhere it appears
	newTypeName := prefix + "_" + typeName
	code = strings.ReplaceAll(code, "type "+typeName+" struct", "type "+newTypeName+" struct")
	code = strings.ReplaceAll(code, "func (m *"+typeName+")", "func (m *"+newTypeName+")")
	code = strings.ReplaceAll(code, "func Decode"+typeName, "func Decode"+newTypeName)
	code = strings.ReplaceAll(code, "&"+typeName+"{", "&"+newTypeName+"{")
	code = strings.ReplaceAll(code, "*"+typeName, "*"+newTypeName)
	code = strings.ReplaceAll(code, " "+typeName+"{", " "+newTypeName+"{")

	// Prefix the helper function decode<Type>WithDecoder
	// This is generated by the code generator for nested struct decoding
	// First replace the function definition
	code = strings.ReplaceAll(code, "func decode"+typeName+"WithDecoder", "func "+prefix+"_decode"+typeName+"WithDecoder")
	// Then replace calls that don't already have the prefix
	// Use a specific pattern: "return decode" to avoid matching the already-prefixed function def
	code = strings.ReplaceAll(code, "return decode"+typeName+"WithDecoder(", "return "+prefix+"_decode"+typeName+"WithDecoder(")

	return code
}

func generateBatchedTestHarness(suites []*TestSuite, typePrefixes []string) string {
	harness := `package main

import (
	"bytes"
	"fmt"
	"math"
	"reflect"

	"github.com/aeolun/json5"
)

type TestResult struct {
	Description  string      ` + "`json:\"description\"`" + `
	Pass         bool        ` + "`json:\"pass\"`" + `
	Error        string      ` + "`json:\"error,omitempty\"`" + `
	EncodedBytes []byte      ` + "`json:\"encoded_bytes,omitempty\"`" + `
	DecodedValue interface{} ` + "`json:\"decoded_value,omitempty\"`" + `
}

func main() {
	_ = math.Pi
	allResults := [][]TestResult{}

`

	// Generate test code for each suite
	for i, suite := range suites {
		typePrefix := typePrefixes[i]
		prefixedType := typePrefix + "_" + suite.TestType

		harness += fmt.Sprintf("\t// Test suite: %s\n", suite.Name)
		harness += "\t{\n"
		harness += "\t\tresults := []TestResult{}\n\n"

		for j, tc := range suite.TestCases {
			harness += fmt.Sprintf("\t\t// Test case %d: %s\n", j, tc.Description)
			harness += "\t\tfunc() {\n"
			harness += fmt.Sprintf("\t\t\tresult := TestResult{Description: %q}\n", tc.Description)
			harness += "\t\t\tdefer func() { results = append(results, result) }()\n\n"

			// Generate value construction with schema information
			harness += generateValueConstructionWithSchema(prefixedType, tc.Value, "testValue", suite)

			// Encode
			harness += "\t\t\tencoded, encErr := testValue.Encode()\n"
			harness += "\t\t\tif encErr != nil {\n"
			harness += "\t\t\t\tresult.Error = fmt.Sprintf(\"encode error: %v\", encErr)\n"
			harness += "\t\t\t\treturn\n"
			harness += "\t\t\t}\n"
			harness += "\t\t\tresult.EncodedBytes = encoded\n\n"

			// Compare bytes
			harness += fmt.Sprintf("\t\t\texpectedBytes := []byte{%s}\n", formatByteSlice(tc.Bytes))
			harness += "\t\t\tif !bytes.Equal(encoded, expectedBytes) {\n"
			harness += "\t\t\t\tresult.Error = fmt.Sprintf(\"encoded bytes mismatch: got %v, want %v\", encoded, expectedBytes)\n"
			harness += "\t\t\t\tresult.Pass = false\n"
			harness += "\t\t\t\treturn\n"
			harness += "\t\t\t}\n\n"

			// Decode
			harness += fmt.Sprintf("\t\t\tdecoded, decErr := Decode%s(encoded)\n", prefixedType)
			harness += "\t\t\tif decErr != nil {\n"
			harness += "\t\t\t\tresult.Error = fmt.Sprintf(\"decode error: %v\", decErr)\n"
			harness += "\t\t\t\treturn\n"
			harness += "\t\t\t}\n"
			harness += "\t\t\tresult.DecodedValue = decoded\n\n"

			// Compare values
			harness += "\t\t\tif !reflect.DeepEqual(decoded, &testValue) {\n"
			harness += "\t\t\t\tresult.Error = fmt.Sprintf(\"decoded value mismatch: got %+v, want %+v\", decoded, testValue)\n"
			harness += "\t\t\t\tresult.Pass = false\n"
			harness += "\t\t\t\treturn\n"
			harness += "\t\t\t}\n\n"

			harness += "\t\t\tresult.Pass = true\n"
			harness += "\t\t}()\n\n"
		}

		harness += "\t\tallResults = append(allResults, results)\n"
		harness += "\t}\n\n"
	}

	harness += `
	// Output results as JSON5
	data, err := json5.Marshal(allResults)
	if err != nil {
		panic(err)
	}
	fmt.Println(string(data))
}
`

	return harness
}

func generateValueConstructionWithSchema(typeName string, value interface{}, varName string, suite *TestSuite) string {
	valueMap, ok := value.(map[string]interface{})
	if !ok {
		return fmt.Sprintf("\t\t\t%s := %s{}\n", varName, typeName)
	}

	// Get the type definition from the schema
	typeDef, ok := suite.Schema["types"].(map[string]interface{})[suite.TestType].(map[string]interface{})
	if !ok {
		// Fallback to simple generation if schema not available
		return generateValueConstructionSimple(typeName, value, varName)
	}

	// Build field type map from schema
	fieldTypes := make(map[string]string)
	if sequence, ok := typeDef["sequence"].([]interface{}); ok {
		for _, fieldRaw := range sequence {
			if field, ok := fieldRaw.(map[string]interface{}); ok {
				if name, ok := field["name"].(string); ok {
					if fieldType, ok := field["type"].(string); ok {
						fieldTypes[name] = fieldType
					}
				}
			}
		}
	}

	result := fmt.Sprintf("\t\t\t%s := %s{\n", varName, typeName)
	for key, val := range valueMap {
		fieldName := capitalizeFirst(key)
		fieldType := fieldTypes[key]
		result += fmt.Sprintf("\t\t\t\t%s: %s,\n", fieldName, formatValueWithType(val, fieldType))
	}
	result += "\t\t\t}\n"

	return result
}

func generateValueConstructionSimple(typeName string, value interface{}, varName string) string {
	valueMap, ok := value.(map[string]interface{})
	if !ok {
		return fmt.Sprintf("\t\t\t%s := %s{}\n", varName, typeName)
	}

	result := fmt.Sprintf("\t\t\t%s := %s{\n", varName, typeName)
	for key, val := range valueMap {
		fieldName := capitalizeFirst(key)
		result += fmt.Sprintf("\t\t\t\t%s: %s,\n", fieldName, formatValue(val))
	}
	result += "\t\t\t}\n"

	return result
}
