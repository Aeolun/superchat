// ABOUTME: Test suite for BinaryReader interface and implementations
// ABOUTME: Validates all reader types work correctly with various data sources

import { describe, it, expect } from "bun:test";
import { 
  BinaryReader, 
  BufferReader, 
  StreamReader,
  createReader 
} from "../../runtime/binary-reader.js";

describe("BufferReader", () => {
  it("should read bytes at position", () => {
    const data = new Uint8Array([0x01, 0x02, 0x03, 0x04, 0x05]);
    const reader = new BufferReader(data);
    
    expect(reader.size).toBe(5);
    expect(reader.seekable).toBe(true);
    
    // Read at various positions
    expect(Array.from(reader.readAt(0, 2))).toEqual([0x01, 0x02]);
    expect(Array.from(reader.readAt(2, 3))).toEqual([0x03, 0x04, 0x05]);
    expect(reader.readByteAt(3)).toBe(0x04);
  });

  it("should handle negative positions (from end)", () => {
    const data = new Uint8Array([0x01, 0x02, 0x03, 0x04, 0x05]);
    const reader = new BufferReader(data);
    
    // Last byte
    expect(reader.readByteAt(-1)).toBe(0x05);
    
    // Last 3 bytes
    expect(Array.from(reader.readAt(-3, 3))).toEqual([0x03, 0x04, 0x05]);
  });

  it("should throw on out-of-bounds access", () => {
    const data = new Uint8Array([0x01, 0x02, 0x03]);
    const reader = new BufferReader(data);
    
    expect(() => reader.readAt(0, 4)).toThrow(/out of bounds/);
    expect(() => reader.readAt(2, 3)).toThrow(/out of bounds/);
    expect(() => reader.readByteAt(3)).toThrow(/out of bounds/);
    expect(() => reader.readByteAt(-4)).toThrow(/out of bounds/);
  });

  it("should support slice operation", () => {
    const data = new Uint8Array([0x01, 0x02, 0x03, 0x04, 0x05]);
    const reader = new BufferReader(data);
    
    expect(Array.from(reader.slice(1, 4))).toEqual([0x02, 0x03, 0x04]);
    expect(Array.from(reader.slice(2))).toEqual([0x03, 0x04, 0x05]);
  });

  it("should provide backward-compatible bytes property", () => {
    const data = new Uint8Array([0x01, 0x02, 0x03]);
    const reader = new BufferReader(data);
    
    expect(reader.bytes).toBe(data);
    expect(Array.from(reader.bytes)).toEqual([0x01, 0x02, 0x03]);
  });

  it("should handle number array input", () => {
    const reader = new BufferReader([0x01, 0x02, 0x03]);
    
    expect(reader.size).toBe(3);
    expect(reader.readByteAt(0)).toBe(0x01);
    expect(reader.readByteAt(1)).toBe(0x02);
    expect(reader.readByteAt(2)).toBe(0x03);
  });
});

describe("StreamReader", () => {
  it("should accumulate chunks", () => {
    const reader = new StreamReader();
    
    reader.addChunk(new Uint8Array([0x01, 0x02]));
    reader.addChunk(new Uint8Array([0x03, 0x04]));
    reader.end();
    
    expect(reader.size).toBe(4);
    expect(reader.seekable).toBe(false);
    
    expect(Array.from(reader.readAt(0, 2))).toEqual([0x01, 0x02]);
    expect(Array.from(reader.readAt(2, 2))).toEqual([0x03, 0x04]);
    expect(reader.readByteAt(1)).toBe(0x02);
  });

  it("should consolidate chunks when reading", () => {
    const reader = new StreamReader();
    
    // Add many small chunks
    for (let i = 0; i < 10; i++) {
      reader.addChunk(new Uint8Array([i]));
    }
    reader.end();
    
    // Read should consolidate
    const data = reader.readAt(0, 10);
    expect(Array.from(data)).toEqual([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]);
  });

  it("should handle reads before stream ends", () => {
    const reader = new StreamReader();
    
    reader.addChunk(new Uint8Array([0x01, 0x02, 0x03]));
    // Not ended yet
    
    expect(reader.size).toBe(-1); // Unknown size
    expect(Array.from(reader.readAt(0, 3))).toEqual([0x01, 0x02, 0x03]);
  });

  it("should throw on out-of-bounds reads", () => {
    const reader = new StreamReader();
    
    reader.addChunk(new Uint8Array([0x01, 0x02]));
    reader.end();
    
    expect(() => reader.readAt(0, 3)).toThrow(/out of bounds/);
    expect(() => reader.readByteAt(2)).toThrow(/out of bounds/);
  });

  it("should support negative positions after stream ends", () => {
    const reader = new StreamReader();
    
    reader.addChunk(new Uint8Array([0x01, 0x02, 0x03, 0x04]));
    reader.end();
    
    expect(reader.readByteAt(-1)).toBe(0x04);
    expect(Array.from(reader.readAt(-2, 2))).toEqual([0x03, 0x04]);
  });
});

describe("createReader", () => {
  it("should create BufferReader for Uint8Array", () => {
    const data = new Uint8Array([0x01, 0x02, 0x03]);
    const reader = createReader(data);
    
    expect(reader).toBeInstanceOf(BufferReader);
    expect(reader.size).toBe(3);
  });

  it("should create BufferReader for number array", () => {
    const reader = createReader([0x01, 0x02, 0x03]);
    
    expect(reader).toBeInstanceOf(BufferReader);
    expect(reader.size).toBe(3);
  });

  it("should handle Node.js Buffer", () => {
    // Simulate Node.js Buffer (which is a Uint8Array subclass)
    const data = new Uint8Array([0x01, 0x02, 0x03]);
    Object.setPrototypeOf(data, Uint8Array.prototype);
    
    const reader = createReader(data);
    expect(reader).toBeInstanceOf(BufferReader);
    expect(reader.size).toBe(3);
  });

  it("should throw for unsupported types", () => {
    expect(() => createReader({})).toThrow(/Unsupported input type/);
    expect(() => createReader(123)).toThrow(/Unsupported input type/);
    expect(() => createReader(null)).toThrow(/Unsupported input type/);
  });
});

describe("BinaryReader interface compliance", () => {
  // Test that all implementations follow the interface correctly
  const implementations: Array<[string, () => BinaryReader]> = [
    ["BufferReader", () => new BufferReader([0x01, 0x02, 0x03, 0x04, 0x05])],
    ["StreamReader", () => {
      const r = new StreamReader();
      r.addChunk(new Uint8Array([0x01, 0x02, 0x03, 0x04, 0x05]));
      r.end();
      return r;
    }]
  ];

  implementations.forEach(([name, createImpl]) => {
    describe(name, () => {
      it("should implement all required methods", () => {
        const reader = createImpl();
        
        // Required properties
        expect(typeof reader.size).toBe("number");
        expect(typeof reader.seekable).toBe("boolean");
        
        // Required methods
        expect(typeof reader.readAt).toBe("function");
        expect(typeof reader.readByteAt).toBe("function");
        expect(typeof reader.slice).toBe("function");
        
        // Optional methods
        if (reader.close) {
          expect(typeof reader.close).toBe("function");
        }
      });

      it("should read data correctly", () => {
        const reader = createImpl();
        
        // Basic reads
        expect(reader.readByteAt(0)).toBe(0x01);
        expect(reader.readByteAt(4)).toBe(0x05);
        expect(Array.from(reader.readAt(1, 2))).toEqual([0x02, 0x03]);
        
        // Slice
        expect(Array.from(reader.slice(2, 4))).toEqual([0x03, 0x04]);
      });

      it("should handle negative positions", () => {
        const reader = createImpl();
        
        expect(reader.readByteAt(-1)).toBe(0x05);
        expect(Array.from(reader.readAt(-3, 2))).toEqual([0x03, 0x04]);
      });

      it("should throw on invalid access", () => {
        const reader = createImpl();
        
        expect(() => reader.readAt(10, 1)).toThrow();
        expect(() => reader.readByteAt(10)).toThrow();
        expect(() => reader.readAt(0, 10)).toThrow();
      });
    });
  });
});
