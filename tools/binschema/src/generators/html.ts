/**
 * HTML Documentation Generator
 *
 * Generates beautiful HTML documentation from a ProtocolSchema + BinarySchema
 */

import { BinarySchema, TypeDef, Field } from "../schema/binary-schema.js";
import { ProtocolSchema, ProtocolMessage } from "../schema/protocol-schema.js";

export interface HTMLGeneratorOptions {
  /** Include CSS inline (default: true) */
  inlineCSS?: boolean;
  /** Include examples section (default: true) */
  includeExamples?: boolean;
  /** Title override */
  title?: string;
}

/**
 * Generate HTML documentation from protocol + binary schemas
 */
export function generateHTML(
  protocolSchema: ProtocolSchema,
  binarySchema: BinarySchema,
  options: HTMLGeneratorOptions = {}
): string {
  const { inlineCSS = true, includeExamples = true } = options;
  const title = options.title || protocolSchema.protocol.name;

  let html = `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>${escapeHtml(title)}</title>
`;

  if (inlineCSS) {
    html += `  <style>\n${generateCSS()}\n  </style>\n`;
  } else {
    html += `  <link rel="stylesheet" href="protocol-docs.css">\n`;
  }

  html += `</head>
<body>
  <header class="protocol-header">
    <h1>${escapeHtml(protocolSchema.protocol.name)}</h1>
    <div class="protocol-version">Version ${escapeHtml(protocolSchema.protocol.version)}</div>
  </header>

  <nav class="toc">
    <h2>Table of Contents</h2>
    <ul>
      <li><a href="#overview">Overview</a></li>
      <li><a href="#frame-format">Frame Format</a></li>
      <li><a href="#data-types">Data Types</a></li>
      <li><a href="#messages">Messages</a></li>
    </ul>
  </nav>

  <main>
`;

  // Overview section
  html += `    <section id="overview" class="section">
      <h2>Overview</h2>
      ${protocolSchema.protocol.description ? `<p>${escapeHtml(protocolSchema.protocol.description)}</p>` : ''}
`;

  if (protocolSchema.protocol.notes && protocolSchema.protocol.notes.length > 0) {
    html += `      <div class="notes">\n`;
    for (const note of protocolSchema.protocol.notes) {
      html += `        <p>${escapeHtml(note)}</p>\n`;
    }
    html += `      </div>\n`;
  }

  html += `    </section>\n\n`;

  // Frame format section
  if (protocolSchema.protocol.header_format) {
    html += generateFrameFormatSection(
      protocolSchema.protocol.header_format,
      binarySchema,
      protocolSchema.protocol.field_descriptions || {}
    );
  }

  // Data types section
  html += generateDataTypesSection(binarySchema, protocolSchema.protocol.field_descriptions || {});

  // Messages section
  html += generateMessagesSection(protocolSchema, binarySchema, includeExamples);

  html += `  </main>

  <footer>
    <p>Generated by BinSchema HTML Generator</p>
  </footer>
</body>
</html>`;

  return html;
}

/**
 * Generate frame format section
 */
function generateFrameFormatSection(
  headerTypeName: string,
  binarySchema: BinarySchema,
  fieldDescriptions: Record<string, string>
): string {
  const headerType = binarySchema.types[headerTypeName] as TypeDef;
  if (!headerType) {
    return `    <section id="frame-format" class="section">
      <h2>Frame Format</h2>
      <p class="error">Header type "${headerTypeName}" not found in schema.</p>
    </section>\n\n`;
  }

  let html = `    <section id="frame-format" class="section">
      <h2>Frame Format</h2>
      <p>All messages use the following frame-based format:</p>

      <div class="wire-format">
`;

  for (const field of headerType.fields) {
    const fieldKey = `${headerTypeName}.${field.name}`;
    const description = fieldDescriptions[fieldKey] || '';
    const typeInfo = getFieldTypeInfo(field, binarySchema);

    html += `        <div class="field">
          <div class="field-name">${escapeHtml(field.name)}</div>
          <div class="field-type">${escapeHtml(typeInfo.displayType)}</div>
          <div class="field-size">${escapeHtml(typeInfo.size)}</div>
          ${description ? `<div class="field-desc">${escapeHtml(description)}</div>` : ''}
        </div>
`;
  }

  html += `      </div>
    </section>\n\n`;

  return html;
}

/**
 * Generate data types section
 */
function generateDataTypesSection(
  binarySchema: BinarySchema,
  fieldDescriptions: Record<string, string>
): string {
  let html = `    <section id="data-types" class="section">
      <h2>Data Types</h2>
      <div class="type-list">
`;

  // Primitive types
  html += `        <details class="type-details">
          <summary><h3>Primitive Types</h3></summary>
          <table class="types-table">
            <thead>
              <tr><th>Type</th><th>Size</th><th>Description</th></tr>
            </thead>
            <tbody>
              <tr><td>uint8</td><td>1 byte</td><td>Unsigned 8-bit integer</td></tr>
              <tr><td>uint16</td><td>2 bytes</td><td>Unsigned 16-bit integer (big-endian)</td></tr>
              <tr><td>uint32</td><td>4 bytes</td><td>Unsigned 32-bit integer (big-endian)</td></tr>
              <tr><td>uint64</td><td>8 bytes</td><td>Unsigned 64-bit integer (big-endian)</td></tr>
              <tr><td>int8</td><td>1 byte</td><td>Signed 8-bit integer</td></tr>
              <tr><td>int16</td><td>2 bytes</td><td>Signed 16-bit integer (big-endian)</td></tr>
              <tr><td>int32</td><td>4 bytes</td><td>Signed 32-bit integer (big-endian)</td></tr>
              <tr><td>int64</td><td>8 bytes</td><td>Signed 64-bit integer (big-endian)</td></tr>
              <tr><td>float32</td><td>4 bytes</td><td>32-bit floating point (IEEE 754)</td></tr>
              <tr><td>float64</td><td>8 bytes</td><td>64-bit floating point (IEEE 754)</td></tr>
            </tbody>
          </table>
        </details>
`;

  // Custom types from schema
  for (const [typeName, typeDef] of Object.entries(binarySchema.types)) {
    // Skip generic templates
    if (typeName.includes('<')) continue;

    html += `        <details class="type-details">
          <summary><h3>${escapeHtml(typeName)}</h3></summary>
          <table class="fields-table">
            <thead>
              <tr><th>Field</th><th>Type</th><th>Description</th></tr>
            </thead>
            <tbody>
`;

    const typeDefObj = typeDef as TypeDef;
    for (const field of typeDefObj.fields) {
      const fieldKey = `${typeName}.${field.name}`;
      const description = fieldDescriptions[fieldKey] || '';
      const typeInfo = getFieldTypeInfo(field, binarySchema);

      html += `              <tr>
                <td>${escapeHtml(field.name)}</td>
                <td><code>${escapeHtml(typeInfo.displayType)}</code></td>
                <td>${escapeHtml(description)}</td>
              </tr>
`;
    }

    html += `            </tbody>
          </table>
        </details>
`;
  }

  html += `      </div>
    </section>\n\n`;

  return html;
}

/**
 * Generate messages section
 */
function generateMessagesSection(
  protocolSchema: ProtocolSchema,
  binarySchema: BinarySchema,
  includeExamples: boolean
): string {
  const messages = protocolSchema.protocol.messages;

  // Group messages by direction
  const clientToServer = messages.filter(m => m.direction === 'client_to_server');
  const serverToClient = messages.filter(m => m.direction === 'server_to_client');
  const bidirectional = messages.filter(m => m.direction === 'bidirectional');

  let html = `    <section id="messages" class="section">
      <h2>Messages</h2>
`;

  if (clientToServer.length > 0) {
    html += `      <h3>Client → Server Messages</h3>
      ${generateMessageTable(clientToServer)}
      ${generateMessageDetails(clientToServer, binarySchema, protocolSchema.protocol.field_descriptions || {}, includeExamples)}
`;
  }

  if (serverToClient.length > 0) {
    html += `      <h3>Server → Client Messages</h3>
      ${generateMessageTable(serverToClient)}
      ${generateMessageDetails(serverToClient, binarySchema, protocolSchema.protocol.field_descriptions || {}, includeExamples)}
`;
  }

  if (bidirectional.length > 0) {
    html += `      <h3>Bidirectional Messages</h3>
      ${generateMessageTable(bidirectional)}
      ${generateMessageDetails(bidirectional, binarySchema, protocolSchema.protocol.field_descriptions || {}, includeExamples)}
`;
  }

  html += `    </section>\n\n`;

  return html;
}

/**
 * Generate message summary table
 */
function generateMessageTable(messages: ProtocolMessage[]): string {
  let html = `      <table class="messages-table">
        <thead>
          <tr><th>Code</th><th>Name</th><th>Description</th></tr>
        </thead>
        <tbody>
`;

  for (const msg of messages) {
    html += `          <tr>
            <td><code>${escapeHtml(msg.code)}</code></td>
            <td><a href="#msg-${msg.code}">${escapeHtml(msg.name)}</a></td>
            <td>${escapeHtml(msg.description)}</td>
          </tr>
`;
  }

  html += `        </tbody>
      </table>
`;

  return html;
}

/**
 * Generate detailed message documentation
 */
function generateMessageDetails(
  messages: ProtocolMessage[],
  binarySchema: BinarySchema,
  fieldDescriptions: Record<string, string>,
  includeExamples: boolean
): string {
  let html = '';

  for (const msg of messages) {
    const payloadType = binarySchema.types[msg.payload_type] as TypeDef;

    html += `      <details class="message-details" id="msg-${msg.code}">
        <summary>
          <h4><code>${escapeHtml(msg.code)}</code> ${escapeHtml(msg.name)}</h4>
        </summary>

        <p class="message-description">${escapeHtml(msg.description)}</p>
`;

    if (msg.notes) {
      html += `        <div class="message-notes">${escapeHtml(msg.notes)}</div>\n`;
    }

    if (payloadType) {
      html += `        <div class="wire-format">
`;
      for (const field of payloadType.fields) {
        const fieldKey = `${msg.payload_type}.${field.name}`;
        const description = fieldDescriptions[fieldKey] || '';
        const typeInfo = getFieldTypeInfo(field, binarySchema);
        const conditional = 'conditional' in field && field.conditional;

        html += `          <div class="field${conditional ? ' conditional' : ''}">
            <div class="field-name">${escapeHtml(field.name)}</div>
            <div class="field-type">${escapeHtml(typeInfo.displayType)}</div>
            <div class="field-size">${escapeHtml(typeInfo.size)}</div>
            ${description ? `<div class="field-desc">${escapeHtml(description)}</div>` : ''}
            ${conditional ? `<div class="field-condition">if ${escapeHtml(field.conditional as string)}</div>` : ''}
          </div>
`;
      }
      html += `        </div>
`;
    } else {
      html += `        <p class="error">Payload type "${msg.payload_type}" not found in schema.</p>\n`;
    }

    if (includeExamples && msg.example) {
      html += `        <details class="example">
          <summary>Wire Format Example</summary>
          <p>${escapeHtml(msg.example.description)}</p>
          <pre class="hex-dump">${formatHexBytes(msg.example.bytes)}</pre>
`;
      if (msg.example.decoded) {
        html += `          <pre class="decoded">${escapeHtml(JSON.stringify(msg.example.decoded, null, 2))}</pre>\n`;
      }
      html += `        </details>
`;
    }

    html += `      </details>\n\n`;
  }

  return html;
}

/**
 * Get field type information for display
 */
function getFieldTypeInfo(field: Field, schema: BinarySchema): { displayType: string; size: string } {
  if (!('type' in field)) {
    return { displayType: 'unknown', size: '?' };
  }

  const type = field.type;

  switch (type) {
    case 'uint8':
    case 'int8':
      return { displayType: type, size: '1 byte' };
    case 'uint16':
    case 'int16':
      return { displayType: type, size: '2 bytes' };
    case 'uint32':
    case 'int32':
    case 'float32':
      return { displayType: type, size: '4 bytes' };
    case 'uint64':
    case 'int64':
    case 'float64':
      return { displayType: type, size: '8 bytes' };
    case 'bit':
      return { displayType: `bit<${field.size}>`, size: `${field.size} bits` };
    case 'array':
      const itemType = field.items && 'type' in field.items ? field.items.type : 'unknown';
      return { displayType: `${itemType}[]`, size: 'variable' };
    default:
      // Custom type reference
      return { displayType: type, size: 'variable' };
  }
}

/**
 * Format hex bytes for display
 */
function formatHexBytes(bytes: number[]): string {
  return bytes.map((b, i) => {
    const hex = b.toString(16).toUpperCase().padStart(2, '0');
    return (i + 1) % 16 === 0 ? hex + '\n' : hex + ' ';
  }).join('').trim();
}

/**
 * Escape HTML special characters
 */
function escapeHtml(text: string): string {
  const map: Record<string, string> = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#039;'
  };
  return text.replace(/[&<>"']/g, m => map[m]);
}

/**
 * Generate CSS stylesheet
 */
function generateCSS(): string {
  return `    /* Protocol Documentation Styles */
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
      line-height: 1.6;
      color: #333;
      background: #f5f5f5;
      padding: 20px;
    }

    .protocol-header {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      padding: 40px 20px;
      border-radius: 8px;
      margin-bottom: 30px;
      text-align: center;
    }

    .protocol-header h1 {
      font-size: 2.5em;
      margin-bottom: 10px;
    }

    .protocol-version {
      font-size: 1.2em;
      opacity: 0.9;
    }

    .toc {
      background: white;
      padding: 20px;
      border-radius: 8px;
      margin-bottom: 30px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }

    .toc h2 {
      margin-bottom: 15px;
      color: #667eea;
    }

    .toc ul {
      list-style: none;
    }

    .toc li {
      margin: 8px 0;
    }

    .toc a {
      color: #667eea;
      text-decoration: none;
      padding: 5px 10px;
      display: inline-block;
      border-radius: 4px;
      transition: background 0.2s;
    }

    .toc a:hover {
      background: #f0f0f0;
    }

    main {
      background: white;
      padding: 30px;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }

    .section {
      margin-bottom: 50px;
    }

    .section h2 {
      color: #667eea;
      border-bottom: 2px solid #667eea;
      padding-bottom: 10px;
      margin-bottom: 20px;
    }

    .section h3 {
      color: #764ba2;
      margin: 30px 0 15px 0;
    }

    .wire-format {
      background: #f9f9f9;
      border: 1px solid #ddd;
      border-radius: 6px;
      padding: 15px;
      margin: 20px 0;
    }

    .field {
      background: white;
      border-left: 4px solid #667eea;
      padding: 12px;
      margin: 8px 0;
      border-radius: 4px;
    }

    .field.conditional {
      border-left-color: #f59e0b;
    }

    .field-name {
      font-weight: bold;
      color: #667eea;
      font-size: 1.1em;
    }

    .field-type {
      font-family: 'Courier New', monospace;
      color: #666;
      margin-top: 4px;
    }

    .field-size {
      color: #999;
      font-size: 0.9em;
      margin-top: 2px;
    }

    .field-desc {
      margin-top: 8px;
      color: #555;
    }

    .field-condition {
      margin-top: 6px;
      padding: 4px 8px;
      background: #fef3c7;
      border-radius: 4px;
      font-family: 'Courier New', monospace;
      font-size: 0.9em;
      color: #92400e;
    }

    table {
      width: 100%;
      border-collapse: collapse;
      margin: 20px 0;
    }

    th, td {
      padding: 12px;
      text-align: left;
      border-bottom: 1px solid #ddd;
    }

    th {
      background: #667eea;
      color: white;
      font-weight: 600;
    }

    tr:hover {
      background: #f9f9f9;
    }

    code {
      background: #f0f0f0;
      padding: 2px 6px;
      border-radius: 3px;
      font-family: 'Courier New', monospace;
      font-size: 0.9em;
    }

    details {
      margin: 15px 0;
    }

    summary {
      cursor: pointer;
      user-select: none;
      padding: 10px;
      background: #f9f9f9;
      border-radius: 4px;
      transition: background 0.2s;
    }

    summary:hover {
      background: #f0f0f0;
    }

    summary h3, summary h4 {
      display: inline;
      margin: 0;
    }

    .message-details {
      border: 1px solid #ddd;
      border-radius: 6px;
      padding: 0;
      margin: 15px 0;
    }

    .message-details summary {
      background: #f5f5f5;
    }

    .message-details[open] summary {
      border-bottom: 1px solid #ddd;
    }

    .message-details > :not(summary) {
      padding: 15px;
    }

    .message-description {
      font-size: 1.1em;
      margin: 15px 0;
    }

    .message-notes {
      background: #eff6ff;
      border-left: 4px solid #3b82f6;
      padding: 12px;
      margin: 15px 0;
      border-radius: 4px;
    }

    .example {
      margin: 20px 0;
      border: 1px solid #ddd;
      border-radius: 4px;
    }

    .hex-dump {
      background: #1e1e1e;
      color: #d4d4d4;
      padding: 15px;
      border-radius: 4px;
      overflow-x: auto;
      font-family: 'Courier New', monospace;
      font-size: 0.9em;
      line-height: 1.4;
    }

    .decoded {
      background: #f9f9f9;
      padding: 15px;
      border-radius: 4px;
      overflow-x: auto;
      font-family: 'Courier New', monospace;
      font-size: 0.9em;
    }

    .error {
      color: #dc2626;
      background: #fee2e2;
      padding: 10px;
      border-radius: 4px;
      border-left: 4px solid #dc2626;
    }

    footer {
      text-align: center;
      padding: 20px;
      color: #999;
      margin-top: 40px;
    }`;
}
