// ABOUTME: Generate HTML documentation for BinSchema type reference
// ABOUTME: Creates beautiful docs from metadata extracted from Zod schemas

import { ExtractedMetadata } from "../schema/extract-metadata.js";
import { formatInlineMarkup } from "./inline-formatting.js";
import { generateWireFormatDiagram } from "./wire-format-diagram.js";
import { normalizeMessageCode } from "../schema/protocol-schema.js";

export interface TypeReferenceOptions {
  /** Include CSS inline (default: true) */
  inlineCSS?: boolean;
  /** Title override */
  title?: string;
  /** Description text for overview section */
  description?: string;
}

/**
 * Generate HTML documentation from extracted metadata
 */
export function generateTypeReferenceHTML(
  metadata: Map<string, ExtractedMetadata>,
  options: TypeReferenceOptions = {},
): string {
  const { inlineCSS = true } = options;
  const title = options.title || "BinSchema Type Reference";
  const description = options.description || "Binary schema type definitions with wire format specifications and code generation mappings.";

  const linkTargets = new Set(Array.from(metadata.keys()));

  let html = `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>${escapeHtml(title)}</title>
`;

  if (inlineCSS) {
    html += `  <style>\n${generateCSS()}\n  </style>\n`;
  } else {
    html += `  <link rel="stylesheet" href="type-reference.css">\n`;
  }

  // Add JavaScript for synchronized tab switching
  html += `  <script>
    // Synchronized tab switching across all code generation views
    document.addEventListener('DOMContentLoaded', () => {
      // Handle tab clicks - synchronize across all tabs on the page
      document.querySelectorAll('.tab-button').forEach(button => {
        button.addEventListener('click', (e) => {
          const btn = e.target;
          const lang = btn.dataset.lang;

          // Update ALL tab buttons and content across the entire page
          document.querySelectorAll('.tab-button').forEach(b => {
            if (b.dataset.lang === lang) {
              b.classList.add('active');
            } else {
              b.classList.remove('active');
            }
          });

          document.querySelectorAll('.tab-content').forEach(content => {
            content.classList.toggle('active', content.dataset.lang === lang);
          });
        });
      });
    });
  </script>
</head>
<body>
  <header class="protocol-header">
    <h1>${escapeHtml(title)}</h1>
    <div class="protocol-version">BinSchema Type System</div>
  </header>

  <nav class="toc">
    <h2>Table of Contents</h2>
    <ul>
      <li><a href="#overview">Overview</a></li>
      <li><a href="#schema-structure">Schema Structure</a></li>
      <li><a href="#protocol-definition">Protocol Definition</a></li>
      <li><a href="#primitive-types">Primitive Types</a></li>
    </ul>
  </nav>

  <main>
`;

  // Overview section
  html += `    <section id="overview" class="section">
      <h2>Overview</h2>
      <p>${escapeHtml(description)}</p>
      <p>This reference documents the overall JSON structure used by BinSchema, the optional protocol metadata layer, and the built-in field types you can use when defining schemas.</p>
    </section>

`;

  // Schema structure section
  html += generateSchemaStructureSection(linkTargets);

  // Protocol section
  html += generateProtocolDefinitionSection(linkTargets);

  // Primitive types section
  html += generateTypesSection(metadata, linkTargets);

  html += `  </main>

  <footer>
    <p>Generated by BinSchema Type Reference Generator</p>
  </footer>
</body>
</html>`;

  return html;
}

interface PropertyDoc {
  name: string;
  type: string;
  required: boolean;
  description: string;
}

interface JsonRenderOptions {
  indent?: number;
  linkTargets?: Set<string>;
  linkKeys?: Set<string>;
}

const SCHEMA_TOP_LEVEL_PROPERTIES: PropertyDoc[] = [
  {
    name: "config",
    type: "object",
    required: false,
    description: "Optional global defaults for endianness and bit ordering. Individual fields can override these settings."
  },
  {
    name: "types",
    type: "record<string, TypeDef>",
    required: true,
    description: "Map of type names to type definitions. Keys must start with an uppercase letter so they never collide with built-in primitives."
  },
  {
    name: "protocol",
    type: "ProtocolDefinition",
    required: false,
    description: "Optional protocol metadata for documenting message-oriented systems. When present, describes headers, message codes, and grouping."
  }
];

const CONFIG_PROPERTIES: PropertyDoc[] = [
  {
    name: "endianness",
    type: `enum ("big_endian" | "little_endian")`,
    required: false,
    description: "Default byte order for multi-byte numeric values. Use field-level `endianness` to override."
  },
  {
    name: "bit_order",
    type: `enum ("msb_first" | "lsb_first")`,
    required: false,
    description: "Default bit ordering for bitfields. Most-significant-bit first (`msb_first`) or least-significant-bit first (`lsb_first`)."
  }
];

const PROTOCOL_PROPERTIES: PropertyDoc[] = [
  {
    name: "name",
    type: "string",
    required: true,
    description: "Human-readable protocol name. Appears in generated documentation."
  },
  {
    name: "version",
    type: "string",
    required: true,
    description: "Protocol version string (for example, `\"1.0\"`)."
  },
  {
    name: "types_schema",
    type: "string",
    required: true,
    description: "Path to the BinarySchema JSON file that defines the types section. Resolved relative to the protocol JSON file."
  },
  {
    name: "description",
    type: "string",
    required: false,
    description: "Optional overview paragraph shown at the top of generated docs."
  },
  {
    name: "header_format",
    type: "string",
    required: false,
    description: "Name of the type in `types` that describes the frame header. Required for frame diagrams and header validation."
  },
  {
    name: "header_size_field",
    type: "string",
    required: false,
    description: "Name of the header field that stores payload size. Used to auto-fill frame examples."
  },
  {
    name: "discriminator_field",
    type: "string",
    required: false,
    description: "Header field (supports dot notation for bitfields) that selects which message payload is on the wire. Required when documenting multiple message codes."
  },
  {
    name: "header_example",
    type: "{ decoded: any }",
    required: false,
    description: "Sample decoded header values shown in generated diagrams. BinSchema fills in missing size fields when possible."
  },
  {
    name: "field_descriptions",
    type: "record<string, string>",
    required: false,
    description: "Map of `Type.field` â†’ human-readable description. Applied across headers and payload types."
  },
  {
    name: "messages",
    type: "ProtocolMessage[]",
    required: true,
    description: "List of documented message codes and payload types. Used to drive tables and payload renderings."
  },
  {
    name: "message_groups",
    type: "MessageGroup[]",
    required: false,
    description: "Optional organization layer that groups message codes into categories."
  },
  {
    name: "constants",
    type: "record<string, ProtocolConstant>",
    required: false,
    description: "Named numeric/string constants referenced by the protocol."
  },
  {
    name: "notes",
    type: "string[]",
    required: false,
    description: "Protocol-wide notes rendered as bullet points."
  }
];

const PROTOCOL_MESSAGE_PROPERTIES: PropertyDoc[] = [
  {
    name: "code",
    type: "string | number",
    required: true,
    description: "Unique message identifier expressed as hex (for example, `\"0x8A\"`). Numeric values are converted to uppercase hex on load."
  },
  {
    name: "name",
    type: "string",
    required: true,
    description: "Message constant name such as `\"AUTH_REQUEST\"`."
  },
  {
    name: "direction",
    type: `enum ("client_to_server" | "server_to_client" | "bidirectional")`,
    required: true,
    description: "Traffic direction hint for documentation tables."
  },
  {
    name: "payload_type",
    type: "string",
    required: true,
    description: "Type name from the BinarySchema `types` map that encodes the payload."
  },
  {
    name: "description",
    type: "string",
    required: false,
    description: "Short summary of what the message conveys."
  },
  {
    name: "notes",
    type: "string | string[]",
    required: false,
    description: "Extended guidance on when or how to use the message. Supports Markdown-style `**bold**` and `*italic*`."
  },
  {
    name: "example",
    type: "{ description: string; bytes: number[]; decoded?: any }",
    required: false,
    description: "Example payload illustrating bytes on the wire. Combined with header_example to build frame diagrams."
  },
  {
    name: "since",
    type: "string",
    required: false,
    description: "Protocol version where the message was introduced."
  },
  {
    name: "deprecated",
    type: "string",
    required: false,
    description: "Marks the version where the message was deprecated."
  }
];

const MESSAGE_GROUP_PROPERTIES: PropertyDoc[] = [
  {
    name: "name",
    type: "string",
    required: true,
    description: "Display name for the group (for example, `\"Authentication\"`)."
  },
  {
    name: "messages",
    type: "Array<string | number>",
    required: true,
    description: "List of message codes included in the group."
  },
  {
    name: "description",
    type: "string",
    required: false,
    description: "Optional description shown beneath the group heading."
  }
];

const PROTOCOL_CONSTANT_PROPERTIES: PropertyDoc[] = [
  {
    name: "value",
    type: "number | string",
    required: true,
    description: "Literal constant value."
  },
  {
    name: "description",
    type: "string",
    required: true,
    description: "Explanation of how the constant is used."
  },
  {
    name: "type",
    type: "string",
    required: false,
    description: "Optional type reference that clarifies the constant's units or bit width."
  }
];

function generateSchemaStructureSection(linkTargets: Set<string>): string {
  const minimalSchemaExample = {
    config: {
      endianness: "big_endian"
    },
    types: {
      FrameHeader: {
        sequence: [
          { name: "length", type: "uint16" },
          { name: "type", type: "uint8" }
        ]
      },
      Ping: {
        sequence: [
          { name: "timestamp", type: "uint64" }
        ]
      }
    }
  };

  let html = `    <section id="schema-structure" class="section">
      <h2>Schema Structure</h2>
      <p>BinSchema documents are JSON (or JSON5) files with three top-level sections. Only <code>types</code> is required; the other sections layer additional context or reusable defaults.</p>
      <p>You can use JSON5 authoring conveniencesâ€”comments, trailing commas, and hex literals are accepted when loading schemas.</p>
`;

  html += renderPropertyTable("Top-Level Properties", SCHEMA_TOP_LEVEL_PROPERTIES);

  html += `      <h3>Config Object</h3>
      <p>The optional <code>config</code> object defines defaults for every field in the schema. Values can be overridden by individual field definitions.</p>
`;

  html += renderPropertyTable("Config Properties", CONFIG_PROPERTIES);

  html += `      <h3>Type Definitions</h3>
      <p>Each entry in the <code>types</code> map defines a reusable structure or alias:</p>
      <ul>
        <li>Composite types use <code>sequence</code> to describe ordered fields on the wire.</li>
        <li>Type aliases reference another type or primitive directly and inherit its wire format &mdash; useful for strings, arrays, or simple wrappers.</li>
        <li>All field definitions ultimately resolve to the built-in type primitives documented later in this guide.</li>
        <li>Type names must start with an uppercase letter; BinSchema enforces this to prevent clashes with built-in primitives.</li>
      </ul>

      <div class="examples">
        <h5>Minimal Types-Only Schema</h5>
        ${renderJsonBlock(minimalSchemaExample, linkTargets)}
      </div>
    </section>

`;

  return html;
}

function generateProtocolDefinitionSection(linkTargets: Set<string>): string {
  const protocolExcerpt = {
    types: {
      FrameHeader: {
        sequence: [
          { name: "length", type: "uint32" },
          { name: "version", type: "uint8" },
          { name: "type", type: "uint8" }
        ]
      },
      Ping: {
        sequence: [
          { name: "timestamp", type: "uint64" }
        ]
      }
    },
    protocol: {
      name: "Example Protocol",
      version: "1.0",
      types_schema: "./example-types.json",
      header_format: "FrameHeader",
      discriminator_field: "type",
      messages: [
        { code: 0x10, name: "PING", direction: "client_to_server", payload_type: "Ping" },
        { code: 0x90, name: "PONG", direction: "server_to_client", payload_type: "Ping" }
      ]
    }
  };

  let html = `    <section id="protocol-definition" class="section">
      <h2>Protocol Definition</h2>
      <p>The optional <code>protocol</code> block documents message-oriented protocols built on top of the binary types. It links a frame header to payload types and captures metadata for documentation.</p>
`;

  html += renderPropertyTable("Protocol Properties", PROTOCOL_PROPERTIES);

  html += renderPropertyTable("ProtocolMessage Properties", PROTOCOL_MESSAGE_PROPERTIES);

  html += renderPropertyTable("MessageGroup Properties", MESSAGE_GROUP_PROPERTIES);

  html += renderPropertyTable("ProtocolConstant Properties", PROTOCOL_CONSTANT_PROPERTIES);

  html += `      <div class="notes">
        <h5>Usage Notes</h5>
        <ul class="notes-list">
          <li><code>discriminator_field</code> becomes mandatory when more than one message code is listed. BinSchema validates the field exists in the header type.</li>
          <li>Message codes provided as integers are automatically converted to uppercase hex strings (for example, <code>0x01</code>).</li>
          <li><code>field_descriptions</code> entries can target either header fields (for example, <code>FrameHeader.length</code>) or payload fields (for example, <code>AuthRequest.nickname</code>).</li>
          <li>When a message provides an <code>example</code>, the generator combines it with <code>header_example</code> to render fully annotated frame diagrams.</li>
        </ul>
      </div>

      <div class="examples">
        <h5>Schema with Protocol Metadata (excerpt)</h5>
        ${renderJsonBlock(protocolExcerpt, linkTargets)}
      </div>
    </section>

`;

  return html;
}

function renderPropertyTable(title: string, properties: PropertyDoc[]): string {
  let html = `      <div class="fields-table">
        <h5>${escapeHtml(title)}</h5>
        <table>
          <thead>
            <tr>
              <th>Property</th>
              <th>Type</th>
              <th>Required</th>
              <th>Description</th>
            </tr>
          </thead>
          <tbody>
`;

  for (const prop of properties) {
    html += `            <tr>
              <td><code>${escapeHtml(prop.name)}</code></td>
              <td><code>${escapeHtml(prop.type)}</code></td>
              <td><span class="badge ${prop.required ? "badge-required" : "badge-optional"}">${prop.required ? "required" : "optional"}</span></td>
              <td>${formatPropertyDescription(prop.description)}</td>
            </tr>
`;
  }

  html += `          </tbody>
        </table>
      </div>

`;

  return html;
}

function formatPropertyDescription(text: string): string {
  const withMarkup = formatInlineMarkup(text);
  return withMarkup.replace(/`([^`]+)`/g, (_match, code) => `<code>${code}</code>`);
}

const DEFAULT_JSON_LINK_KEYS = new Set<string>(["type"]);

function renderJsonBlock(value: unknown, linkTargets: Set<string>): string {
  const jsonHtml = renderHighlightedJson(value, {
    linkTargets
  });
  return `<pre><code>${jsonHtml}</code></pre>`;
}

function renderHighlightedJson(value: unknown, options: JsonRenderOptions = {}): string {
  const resolvedOptions = {
    indent: options.indent ?? 2,
    linkTargets: options.linkTargets ?? new Set<string>(),
    linkKeys: options.linkKeys ?? DEFAULT_JSON_LINK_KEYS
  };

  return renderJsonValue(value, resolvedOptions, null, 0, null);
}

function renderJsonValue(
  value: unknown,
  options: { indent: number; linkTargets: Set<string>; linkKeys: Set<string> },
  currentKey: string | null,
  depth: number,
  parentKey: string | null
): string {
  if (value === null) {
    return `<span class="json-null">null</span>`;
  }

  if (Array.isArray(value)) {
    return renderJsonArray(value, options, depth, currentKey);
  }

  switch (typeof value) {
    case "object":
      return renderJsonObject(value as Record<string, unknown>, options, depth);
    case "string":
      return renderJsonString(value, { linkTargets: options.linkTargets, linkKeys: options.linkKeys }, currentKey);
    case "number":
      return renderJsonNumber(
        value,
        { ...options, currentKey, parentKey }
      );
    case "boolean":
      return `<span class="json-boolean">${value}</span>`;
    default:
      return `<span class="json-null">null</span>`;
  }
}

function renderJsonObject(
  obj: Record<string, unknown>,
  options: { indent: number; linkTargets: Set<string>; linkKeys: Set<string> },
  depth: number
): string {
  const keys = Object.keys(obj);
  if (keys.length === 0) {
    return "{}";
  }

  const indent = " ".repeat(depth * options.indent);
  const nextIndent = " ".repeat((depth + 1) * options.indent);

  let result = "{\n";

  keys.forEach((key, index) => {
    const keyToken = `<span class="json-key">"${escapeHtml(key)}"</span>`;
    const valueToken = renderJsonValue(obj[key], options, key, depth + 1, null);
    const suffix = index < keys.length - 1 ? "," : "";
    result += `${nextIndent}${keyToken}: ${valueToken}${suffix}\n`;
  });

  result += `${indent}}`;
  return result;
}

function renderJsonArray(
  arr: unknown[],
  options: { indent: number; linkTargets: Set<string>; linkKeys: Set<string> },
  depth: number,
  parentKey: string | null
): string {
  if (arr.length === 0) {
    return "[]";
  }

  const indent = " ".repeat(depth * options.indent);
  const nextIndent = " ".repeat((depth + 1) * options.indent);
  let result = "[\n";

  arr.forEach((item, index) => {
    const valueToken = renderJsonValue(item, options, null, depth + 1, parentKey);
    const suffix = index < arr.length - 1 ? "," : "";
    result += `${nextIndent}${valueToken}${suffix}\n`;
  });

  result += `${indent}]`;
  return result;
}

function renderJsonString(
  value: string,
  options: { linkTargets: Set<string>; linkKeys: Set<string> },
  currentKey: string | null
): string {
  const jsonString = JSON.stringify(value);
  const inner = escapeHtml(jsonString.slice(1, -1));

  const linkedInner = maybeRenderTypeLink(inner, value, options, currentKey);

  return `<span class="json-string">&quot;${linkedInner}&quot;</span>`;
}

function renderJsonNumber(
  value: number,
  options: { indent: number; linkTargets: Set<string>; linkKeys: Set<string>; currentKey: string | null; parentKey: string | null }
): string {
  if (!Number.isFinite(value)) {
    return `<span class="json-null">null</span>`;
  }

  const isMessageCode =
    options.currentKey === "code" ||
    options.parentKey === "messages";

  if (isMessageCode) {
    try {
      const normalized = normalizeMessageCode(value);
      return `<span class="json-number json-number-hex">${normalized}</span>`;
    } catch {
      // fall through to default formatting
    }
  }

  return `<span class="json-number">${value}</span>`;
}

function maybeRenderTypeLink(
  escapedInner: string,
  rawValue: string,
  options: { linkTargets: Set<string>; linkKeys: Set<string> },
  currentKey: string | null
): string {
  if (!currentKey || !options.linkKeys.has(currentKey)) {
    return escapedInner;
  }

  if (!options.linkTargets.has(rawValue)) {
    return escapedInner;
  }

  const anchorId = `type-${rawValue}`;
  const href = `#${anchorId}`;
  return `<a href="${escapeHtml(href)}" class="type-link">${escapedInner}</a>`;
}

/**
 * Generate types section with all documented types
 */
function generateTypesSection(metadata: Map<string, ExtractedMetadata>, linkTargets: Set<string>): string {
  let html = `    <section id="primitive-types" class="section">
      <h2>Primitive Types</h2>
      <div class="type-list">
`;

  // Group types by category
  const categories = {
    "Unsigned Integers": ["uint8", "uint16", "uint32", "uint64"],
    "Signed Integers": ["int8", "int16", "int32", "int64"],
    "Floating Point": ["float32", "float64"],
    "Complex Types": ["string", "array", "optional", "discriminated_union", "bitfield", "back_reference"],
  };

  // Track which types we've rendered
  const renderedTypes = new Set<string>();

  for (const [categoryName, typeNames] of Object.entries(categories)) {
    html += `        <div class="type-category">
          <h3>${escapeHtml(categoryName)}</h3>
`;

    for (const typeName of typeNames) {
      const meta = metadata.get(typeName);
      if (meta) {
        html += generateTypeSection(typeName, meta, linkTargets);
        renderedTypes.add(typeName);
      }
    }

    html += `        </div>
`;
  }

  // Add "Other Types" category for any types not explicitly categorized
  const otherTypes = Array.from(metadata.keys()).filter(name => !renderedTypes.has(name)).sort();

  if (otherTypes.length > 0) {
    html += `        <div class="type-category">
          <h3>Other Types</h3>
`;

    for (const typeName of otherTypes) {
      const meta = metadata.get(typeName);
      if (meta) {
        html += generateTypeSection(typeName, meta, linkTargets);
      }
    }

    html += `        </div>
`;
  }

  html += `      </div>
    </section>

`;

  return html;
}

/**
 * Generate section for a single type
 */
function generateTypeSection(typeName: string, meta: ExtractedMetadata, linkTargets: Set<string>): string {
  let html = `          <details class="type-details" id="type-${typeName}">
            <summary>
              <h4><code>${escapeHtml(typeName)}</code></h4>
              ${meta.title ? `<span class="type-title">${escapeHtml(meta.title)}</span>` : ""}
            </summary>
            <div class="type-content">
`;

  // Description
  if (meta.description) {
    html += `              <p class="type-description">${formatInlineMarkup(meta.description)}</p>
`;
  }

  // Use cases
  if (meta.use_for) {
    html += `              <div class="use-for">
                <strong>Use for:</strong> ${escapeHtml(meta.use_for)}
              </div>
`;
  }

  // Wire format - show diagram for complex types, text for primitives
  if (meta.wire_format) {
    const wireFormatDiagram = generateWireFormatDiagram(typeName, meta);
    if (wireFormatDiagram) {
      html += wireFormatDiagram;
    } else {
      html += `              <div class="wire-format-info">
                <strong>Wire format:</strong> <code>${escapeHtml(meta.wire_format)}</code>
              </div>
`;
    }
  }

  // Fields/Properties table
  if (meta.fields && meta.fields.length > 0) {
    html += generateFieldsTable(meta.fields);
  }

  // Code generation section with tabs
  if (meta.code_generation) {
    html += generateCodeGenerationTabs(meta.code_generation);
  }

  // General notes (not language-specific)
  if (meta.notes && meta.notes.length > 0) {
    html += `              <div class="notes">
                <h5>Notes</h5>
                <ul class="notes-list">
`;
    for (const note of meta.notes) {
      html += `                  <li>${formatInlineMarkup(note)}</li>
`;
    }
    html += `                </ul>
              </div>
`;
  }

  // Examples section - schema definitions + tabbed values
  if (meta.examples && meta.examples.length > 0) {
    html += generateExamplesSection(meta.examples, meta.examples_values, linkTargets);
  }

  html += `            </div>
          </details>
`;

  return html;
}

/**
 * Generate examples section with schema + value table per language
 */
function generateExamplesSection(
  examples: unknown[],
  examplesValues: ExtractedMetadata["examples_values"] | undefined,
  linkTargets: Set<string>
): string {
  const schemaHtml = renderHighlightedJson(examples, {
    linkTargets
  });

  // If no value examples, just show schema
  if (!examplesValues) {
    return `              <div class="examples">
                <h5>Examples</h5>
                <pre><code>${schemaHtml}</code></pre>
              </div>
`;
  }

  const languages = Object.keys(examplesValues).filter(lang => examplesValues[lang as keyof typeof examplesValues]);

  if (languages.length === 0) {
    return `              <div class="examples">
                <h5>Examples</h5>
                <pre><code>${schemaHtml}</code></pre>
              </div>
`;
  }

  // Generate tabbed table view
  let html = `              <div class="examples-table">
                <h5>Examples</h5>
                <div class="tabs">
`;

  // Tab buttons
  languages.forEach((lang, idx) => {
    const active = idx === 0 ? " active" : "";
    const displayName = lang.charAt(0).toUpperCase() + lang.slice(1);
    html += `                  <button class="tab-button${active}" data-lang="${lang}">${escapeHtml(displayName)}</button>
`;
  });

  html += `                </div>
`;

  // Tab contents - each is a table with Schema | Value columns
  languages.forEach((lang, idx) => {
    const active = idx === 0 ? " active" : "";
    const valueCode = examplesValues[lang as keyof typeof examplesValues];

    html += `                <div class="tab-content${active}" data-lang="${lang}">
                  <table class="example-table">
                    <thead>
                      <tr>
                        <th>Schema Definition</th>
                        <th>Example Values</th>
                      </tr>
                    </thead>
                    <tbody>
                      <tr>
                        <td><pre><code>${schemaHtml}</code></pre></td>
                        <td><pre><code>${escapeHtml(valueCode!)}</code></pre></td>
                      </tr>
                    </tbody>
                  </table>
                </div>
`;
  });

  html += `              </div>
`;

  return html;
}

/**
 * Format type name with element/variant information
 */
function formatTypeName(field: any): string {
  // For union types with options, extract element types
  if (field.type === "union" && field.unionOptions && field.unionOptions.length > 0) {
    // Get unique types from union options
    const types = new Set<string>();
    for (const option of field.unionOptions) {
      for (const subField of option.fields) {
        types.add(subField.type);
      }
    }

    // If this is an array items field (based on field name), format as Array<T>
    if (field.name === "items" && types.size > 0) {
      // For single type, use Array<Type>
      if (types.size === 1) {
        return `Array<${Array.from(types)[0]}>`;
      }
      // For multiple types, use Array<Type1 | Type2 | ...>
      return `Array<${Array.from(types).join(" | ")}>`;
    }

    if (types.size > 0) {
      return `union (${Array.from(types).join(" | ")})`;
    }
  }

  return field.type;
}

/**
 * Format constraints for display
 */
function formatConstraints(constraints: any[] | undefined): string {
  if (!constraints || constraints.length === 0) {
    return "";
  }

  const parts: string[] = [];

  for (const c of constraints) {
    switch (c.type) {
      case "min_length":
        parts.push(`min length: ${c.value}`);
        break;
      case "max_length":
        parts.push(`max length: ${c.value}`);
        break;
      case "exact_length":
        parts.push(`length: ${c.value}`);
        break;
      case "min":
        parts.push(c.inclusive ? `min: ${c.value}` : `> ${c.value}`);
        break;
      case "max":
        parts.push(c.inclusive ? `max: ${c.value}` : `< ${c.value}`);
        break;
      case "greater_than":
        parts.push(`> ${c.value}`);
        break;
      case "less_than":
        parts.push(`< ${c.value}`);
        break;
      case "format":
        parts.push(`format: ${c.format}`);
        break;
      case "pattern":
        parts.push(`pattern: <code>${c.pattern}</code>`);
        break;
      case "multiple_of":
        parts.push(`multiple of: ${c.value}`);
        break;
    }
  }

  return parts.length > 0 ? ` <span class="constraints">(${parts.join(", ")})</span>` : "";
}

/**
 * Generate fields/properties table
 */
function generateFieldsTable(fields: NonNullable<ExtractedMetadata["fields"]>): string {
  let html = `              <div class="fields-table">
                <h5>Properties</h5>
                <table>
                  <thead>
                    <tr>
                      <th>Property</th>
                      <th>Type</th>
                      <th>Required</th>
                      <th>Description</th>
                    </tr>
                  </thead>
                  <tbody>
`;

  for (const field of fields) {
    const requiredBadge = field.required
      ? '<span class="badge badge-required">required</span>'
      : '<span class="badge badge-optional">optional</span>';

    // Regular field row
    const typeName = formatTypeName(field);
    const constraints = formatConstraints((field as any).constraints);
    html += `                    <tr>
                      <td><code>${escapeHtml(field.name)}</code></td>
                      <td><code>${escapeHtml(typeName)}</code>${constraints}</td>
                      <td>${requiredBadge}</td>
                      <td>${field.description ? formatInlineMarkup(field.description) : ''}${field.default ? ` <em>(default: ${escapeHtml(field.default)})</em>` : ''}</td>
                    </tr>
`;

    // If this field has union options, display them as sub-rows
    if (field.unionOptions && field.unionOptions.length > 0) {
      field.unionOptions.forEach((option, optionIdx) => {
        // Header row for this option
        html += `                    <tr class="union-option-header">
                      <td colspan="4"><strong>Option ${optionIdx + 1}:</strong></td>
                    </tr>
`;

        // Sub-rows for each field in this option
        option.fields.forEach(subField => {
          const subRequiredBadge = subField.required
            ? '<span class="badge badge-required">required</span>'
            : '<span class="badge badge-optional">optional</span>';

          html += `                    <tr class="union-option-field">
                      <td><code>&nbsp;&nbsp;${escapeHtml(subField.name)}</code></td>
                      <td><code>${escapeHtml(subField.type)}</code></td>
                      <td>${subRequiredBadge}</td>
                      <td>${subField.description ? formatInlineMarkup(subField.description) : ''}</td>
                    </tr>
`;
        });
      });
    }

    // If this field is an array with element structure, display element fields
    if ((field as any).arrayElement?.fields) {
      const arrayElement = (field as any).arrayElement;

      // Header row for array elements
      html += `                    <tr class="union-option-header">
                      <td colspan="4"><strong>Array Element Fields:</strong></td>
                    </tr>
`;

      // Sub-rows for each field in the element
      arrayElement.fields.forEach((elemField: any) => {
        const elemRequiredBadge = elemField.required
          ? '<span class="badge badge-required">required</span>'
          : '<span class="badge badge-optional">optional</span>';

        html += `                    <tr class="union-option-field">
                      <td><code>&nbsp;&nbsp;${escapeHtml(elemField.name)}</code></td>
                      <td><code>${escapeHtml(elemField.type)}</code></td>
                      <td>${elemRequiredBadge}</td>
                      <td>${elemField.description ? formatInlineMarkup(elemField.description) : ''}</td>
                    </tr>
`;
      });
    }
  }

  html += `                  </tbody>
                </table>
              </div>
`;

  return html;
}

/**
 * Generate tabbed view for code generation
 */
function generateCodeGenerationTabs(
  codeGen: NonNullable<ExtractedMetadata["code_generation"]>
): string {
  const languages = Object.keys(codeGen).filter(lang => codeGen[lang as keyof typeof codeGen]);

  if (languages.length === 0) {
    return "";
  }

  let html = `              <div class="tabs-container">
                <h5>Generated Code</h5>
                <div class="tabs">
`;

  // Tab buttons
  languages.forEach((lang, idx) => {
    const active = idx === 0 ? " active" : "";
    const displayName = lang.charAt(0).toUpperCase() + lang.slice(1);
    html += `                  <button class="tab-button${active}" data-lang="${lang}">${escapeHtml(displayName)}</button>
`;
  });

  html += `                </div>
`;

  // Tab contents
  languages.forEach((lang, idx) => {
    const active = idx === 0 ? " active" : "";
    const langData = codeGen[lang as keyof typeof codeGen];

    html += `                <div class="tab-content${active}" data-lang="${lang}">
                  <div class="code-type">
                    <strong>Type:</strong> <code>${escapeHtml(langData!.type)}</code>
                  </div>
`;

    if (langData!.notes && langData!.notes.length > 0) {
      html += `                  <ul class="code-notes">
`;
      for (const note of langData!.notes) {
        html += `                    <li>${formatInlineMarkup(note)}</li>
`;
      }
      html += `                  </ul>
`;
    }

    html += `                </div>
`;
  });

  html += `              </div>
`;

  return html;
}

/**
 * Escape HTML special characters
 */
function escapeHtml(text: string): string {
  const map: Record<string, string> = {
    "&": "&amp;",
    "<": "&lt;",
    ">": "&gt;",
    '"': "&quot;",
    "'": "&#039;",
  };
  return text.replace(/[&<>"']/g, (m) => map[m]);
}

/**
 * Generate CSS stylesheet (borrows heavily from protocol HTML generator)
 */
function generateCSS(): string {
  return `    /* Type Reference Documentation Styles */
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
      line-height: 1.6;
      color: #333;
      background: #f5f5f5;
      padding: 20px;
    }

    .protocol-header {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      padding: 40px 20px;
      border-radius: 8px;
      margin-bottom: 30px;
      text-align: center;
    }

    .protocol-header h1 {
      font-size: 2.5em;
      margin-bottom: 10px;
    }

    .protocol-version {
      font-size: 1.2em;
      opacity: 0.9;
    }

    .toc {
      background: white;
      padding: 20px;
      border-radius: 8px;
      margin-bottom: 30px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }

    .toc h2 {
      margin-bottom: 15px;
      color: #667eea;
    }

    .toc ul {
      list-style: none;
    }

    .toc li {
      margin: 8px 0;
    }

    .toc a {
      color: #667eea;
      text-decoration: none;
      padding: 5px 10px;
      display: inline-block;
      border-radius: 4px;
      transition: background 0.2s;
    }

    .toc a:hover {
      background: #f0f0f0;
    }

    main {
      background: white;
      padding: 30px;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }

    .section {
      margin-bottom: 50px;
    }

    .section h2 {
      color: #667eea;
      border-bottom: 2px solid #667eea;
      padding-bottom: 10px;
      margin-bottom: 20px;
    }

    .section h3 {
      color: #764ba2;
      margin: 30px 0 15px 0;
    }

    .section ul {
      list-style: disc;
      margin: 15px 0 20px 1.5rem;
      padding-left: 1rem;
    }

    .section ul li {
      margin: 6px 0;
    }

    .type-link {
      color: #2563eb;
      text-decoration: none;
      border-bottom: 1px dotted rgba(37, 99, 235, 0.45);
    }

    .type-link:hover {
      border-bottom-style: solid;
    }

    .type-category {
      margin-bottom: 40px;
    }

    .type-details {
      border: 1px solid #e5e7eb;
      border-radius: 6px;
      padding: 0;
      margin: 15px 0;
      background: white;
    }

    .type-details summary {
      padding: 15px;
      background: #f9fafb;
      cursor: pointer;
      user-select: none;
      border-radius: 6px;
      transition: background 0.2s;
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .type-details summary:hover {
      background: #f3f4f6;
    }

    .type-details[open] summary {
      border-bottom: 1px solid #e5e7eb;
      border-radius: 6px 6px 0 0;
    }

    .type-details summary h4 {
      display: inline;
      margin: 0;
      font-size: 1.1em;
    }

    .type-title {
      color: #6b7280;
      font-size: 0.95em;
      font-weight: normal;
    }

    .type-content {
      padding: 20px;
    }

    .type-description {
      font-size: 1.05em;
      margin-bottom: 20px;
      line-height: 1.7;
      color: #374151;
    }

    .use-for, .wire-format-info {
      background: #f0f9ff;
      border-left: 4px solid #0ea5e9;
      padding: 12px 15px;
      margin: 15px 0;
      border-radius: 4px;
    }

    /* Wire format diagrams */
    .wire-format {
      background: #f9f9f9;
      border-top: 1px solid #ddd;
      border-bottom: 1px solid #ddd;
      padding: 20px;
      margin: 20px 0;
      overflow-x: auto;
    }

    .wire-diagram {
      display: flex;
      flex-direction: row;
      gap: 0;
      min-width: 100%;
      margin-bottom: 15px;
    }

    .field {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      border: 2px solid #555;
      border-right: none;
      padding: 12px 8px;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      text-align: center;
      min-height: 80px;
      position: relative;
      box-sizing: border-box;
    }

    .field:last-child {
      border-right: 2px solid #555;
    }

    .field-name {
      font-weight: bold;
      color: white;
      font-size: 0.9em;
      margin-bottom: 4px;
      word-wrap: break-word;
      max-width: 100%;
    }

    .field-type {
      font-family: 'Courier New', monospace;
      color: rgba(255, 255, 255, 0.9);
      font-size: 0.75em;
      margin-bottom: 2px;
    }

    .field-size {
      color: rgba(255, 255, 255, 0.7);
      font-size: 0.7em;
      font-weight: 600;
    }

    .notes {
      background: #fffbeb;
      border-left: 4px solid #f59e0b;
      padding: 12px 15px;
      margin: 20px 0;
      border-radius: 4px;
    }

    .notes h5 {
      margin: 0 0 10px 0;
      color: #92400e;
      font-size: 0.95em;
      font-weight: 600;
    }

    .notes-list {
      margin: 0;
      padding-left: 20px;
      list-style-type: disc;
    }

    .notes-list li {
      margin: 6px 0;
      color: #78350f;
      line-height: 1.6;
    }

    .examples {
      margin: 20px 0;
    }

    .examples h5 {
      margin: 0 0 10px 0;
      color: #4b5563;
      font-size: 0.95em;
      font-weight: 600;
    }

    .examples pre {
      background: #1e1e1e;
      color: #d4d4d4;
      padding: 15px;
      border-radius: 4px;
      overflow-x: auto;
      font-family: 'Monaco', 'Menlo', 'Courier New', monospace;
      font-size: 0.85em;
      line-height: 1.5;
    }

    /* Examples table with tabs */
    .examples-table {
      margin: 20px 0;
    }

    .examples-table h5 {
      margin: 0 0 10px 0;
      color: #4b5563;
      font-size: 0.95em;
      font-weight: 600;
    }

    .examples-table .tabs {
      display: flex;
      gap: 0;
      border-bottom: 2px solid #e5e7eb;
      background: #f9fafb;
      border-radius: 4px 4px 0 0;
    }

    .examples-table .tab-content {
      display: none;
    }

    .examples-table .tab-content.active {
      display: block;
    }

    .example-table {
      width: 100%;
      table-layout: fixed;
      border-collapse: collapse;
      border: 1px solid #e5e7eb;
      border-radius: 0 0 6px 6px;
      overflow: hidden;
    }

    .example-table thead {
      background: #f9fafb;
    }

    .example-table th {
      text-align: left;
      padding: 12px 15px;
      font-weight: 600;
      font-size: 0.9em;
      color: #374151;
      border-bottom: 2px solid #e5e7eb;
      width: 50%;
    }

    .example-table td {
      padding: 0;
      vertical-align: top;
      width: 50%;
    }

    .fields-table table th:nth-child(1),
    .fields-table table td:nth-child(1) {
      width: 15%;
    }

    .fields-table table th:nth-child(2),
    .fields-table table td:nth-child(2) {
      width: 20%;
    }

    .fields-table table th:nth-child(3),
    .fields-table table td:nth-child(3) {
      width: 15%;
    }

    .fields-table table th:nth-child(4),
    .fields-table table td:nth-child(4) {
      width: 50%;
    }

    .example-table thead th:nth-child(1),
    .example-table tbody td:nth-child(1) {
      width: 35%;
    }

    .example-table thead th:nth-child(2),
    .example-table tbody td:nth-child(2) {
      width: 65%;
    }

    .example-table td pre {
      margin: 0;
      background: #1e1e1e;
      color: #d4d4d4;
      padding: 15px;
      border-radius: 0;
      overflow-x: auto;
      font-family: 'Monaco', 'Menlo', 'Courier New', monospace;
      font-size: 0.85em;
      line-height: 1.5;
    }

    .example-table td:first-child {
      border-right: 1px solid #e5e7eb;
    }

    code {
      background: #f3f4f6;
      padding: 2px 6px;
      border-radius: 3px;
      font-family: 'Monaco', 'Menlo', 'Courier New', monospace;
      font-size: 0.9em;
      color: #1f2937;
    }

    pre code {
      background: none;
      padding: 0;
      color: inherit;
    }

    .json-key {
      color: #b58900;
    }

    .json-string {
      color: #268bd2;
    }

    .json-number {
      color: #d33682;
    }
    .json-number-hex {
      color: #d33682;
    }

    .json-boolean {
      color: #cb4b16;
    }

    .json-null {
      color: #6b7280;
    }

    .json-string .type-link {
      color: inherit;
      border-bottom-color: rgba(38, 139, 210, 0.45);
    }


    /* Tabbed code generation view */
    .tabs-container {
      background: #ffffff;
      border: 1px solid #e5e7eb;
      border-radius: 6px;
      margin: 20px 0;
      overflow: hidden;
    }

    .tabs-container h5 {
      margin: 0;
      padding: 12px 15px;
      background: #f9fafb;
      border-bottom: 1px solid #e5e7eb;
      color: #4b5563;
      font-size: 0.95em;
      font-weight: 600;
    }

    .tabs {
      display: flex;
      gap: 0;
      border-bottom: 2px solid #e5e7eb;
      background: #f9fafb;
    }

    .tab-button {
      flex: 1;
      padding: 12px 20px;
      background: #f9fafb;
      border: none;
      border-bottom: 3px solid transparent;
      cursor: pointer;
      font-size: 0.95em;
      font-weight: 500;
      color: #6b7280;
      transition: all 0.2s;
    }

    .tab-button:hover {
      background: #f3f4f6;
      color: #374151;
    }

    .tab-button.active {
      background: white;
      color: #667eea;
      border-bottom-color: #667eea;
    }

    .tab-content {
      display: none;
      padding: 20px;
    }

    .tab-content.active {
      display: block;
    }

    .code-type {
      font-size: 1.05em;
      margin-bottom: 15px;
    }

    .code-type code {
      background: #dbeafe;
      color: #1e40af;
      padding: 4px 8px;
      font-size: 1em;
      font-weight: 600;
    }

    .code-notes {
      margin: 0;
      padding-left: 20px;
      list-style-type: disc;
    }

    .code-notes li {
      margin: 8px 0;
      color: #4b5563;
      line-height: 1.6;
    }

    .code-example {
      margin-top: 20px;
    }

    .code-example h6 {
      margin: 0 0 10px 0;
      color: #4b5563;
      font-size: 0.9em;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .code-example pre {
      background: #1e1e1e;
      color: #d4d4d4;
      padding: 15px;
      border-radius: 4px;
      overflow-x: auto;
      font-family: 'Monaco', 'Menlo', 'Courier New', monospace;
      font-size: 0.85em;
      line-height: 1.5;
      margin: 0;
    }

    .code-example pre code {
      background: none;
      padding: 0;
      color: inherit;
    }

    /* Fields table */
    .fields-table {
      margin: 20px 0;
    }

    .fields-table h5 {
      margin: 0 0 12px 0;
      color: #4b5563;
      font-size: 0.95em;
      font-weight: 600;
    }

    .fields-table table {
      width: 100%;
      table-layout: fixed;
      border-collapse: collapse;
      border: 1px solid #e5e7eb;
      border-radius: 6px;
      overflow: hidden;
    }

    .fields-table thead {
      background: #f9fafb;
    }

    .fields-table th {
      text-align: left;
      padding: 12px 15px;
      font-weight: 600;
      font-size: 0.9em;
      color: #374151;
      border-bottom: 2px solid #e5e7eb;
    }

    .fields-table td {
      padding: 12px 15px;
      border-bottom: 1px solid #e5e7eb;
      color: #4b5563;
      vertical-align: top;
    }

    .fields-table tbody tr:last-child td {
      border-bottom: none;
    }

    .fields-table tbody tr:hover {
      background: #f9fafb;
    }

    .fields-table code {
      background: #f3f4f6;
      padding: 2px 6px;
      border-radius: 3px;
      font-size: 0.85em;
      color: #1f2937;
    }

    .badge {
      display: inline-block;
      padding: 3px 8px;
      border-radius: 3px;
      font-size: 0.75em;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .badge-required {
      background: #fee2e2;
      color: #991b1b;
    }

    .badge-optional {
      background: #e0e7ff;
      color: #3730a3;
    }

    .constraints {
      color: #6b7280;
      font-size: 0.85em;
      font-weight: normal;
      font-style: italic;
    }

    .constraints code {
      font-style: normal;
    }

    /* Union option styles */
    .union-option-header td {
      background: #f0f9ff;
      padding: 8px 15px;
      font-size: 0.9em;
      color: #0369a1;
      border-top: 1px solid #bae6fd;
    }

    .union-option-field {
      background: #fafafa;
    }

    .union-option-field td {
      padding-left: 30px;
    }

    .union-option-field:hover {
      background: #f5f5f5 !important;
    }

    footer {
      text-align: center;
      padding: 20px;
      color: #999;
      margin-top: 40px;
    }`;
}
